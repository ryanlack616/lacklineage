<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lack Lineage — Tree</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f8f6f1;
  --bg2: #fff;
  --fg: #2a2520;
  --fg2: #6b6360;
  --accent: #8b6914;
  --accent2: #a07d2a;
  --border: #d8d2c8;
  --radius: 6px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08);
  --font: 'Georgia', 'Times New Roman', serif;
  --mono: 'Consolas', 'Monaco', monospace;
  --male: #4a7fb5;
  --female: #b5564a;
  --unknown: #888;
}
html, body { height: 100%; overflow: hidden; }
body { font-family: var(--font); color: var(--fg); background: var(--bg); }

/* ── Header ── */
header {
  background: var(--fg);
  color: var(--bg);
  padding: 0.75rem 2rem;
  display: flex;
  align-items: center;
  gap: 2rem;
  z-index: 10;
}
header h1 { font-size: 1.1rem; letter-spacing: 0.05em; white-space: nowrap; }
header h1 span { font-weight: 300; opacity: 0.6; }
header h1 a { color: inherit; text-decoration: none; }
nav { display: flex; gap: 0.5rem; flex-wrap: wrap; }
nav a {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--bg);
  padding: 0.3rem 0.7rem;
  border-radius: var(--radius);
  font-family: var(--font);
  font-size: 0.8rem;
  text-decoration: none;
  transition: all 0.15s;
}
nav a:hover, nav a.active {
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.4);
}
nav a.active { font-weight: bold; }

/* ── Controls ── */
.controls {
  position: fixed;
  top: 60px;
  left: 1rem;
  z-index: 5;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1rem;
  box-shadow: var(--shadow);
  font-size: 0.8rem;
  max-width: 260px;
  max-height: calc(100vh - 80px);
  overflow-y: auto;
}
.controls h3 { font-size: 0.85rem; margin-bottom: 0.5rem; color: var(--accent); }
.controls label { display: block; margin: 0.4rem 0 0.15rem; color: var(--fg2); font-size: 0.75rem; }
.controls select, .controls input[type="text"] {
  width: 100%;
  font-family: var(--font);
  font-size: 0.8rem;
  padding: 0.3rem 0.5rem;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: var(--bg2);
}
.controls input[type="range"] {
  width: 100%;
}
.controls .stat { margin-top: 0.6rem; color: var(--fg2); line-height: 1.4; font-size: 0.75rem; }
.controls .stat strong { color: var(--fg); }
.controls button {
  margin-top: 0.5rem;
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 0.35rem 0.7rem;
  border-radius: var(--radius);
  cursor: pointer;
  font-family: var(--font);
  font-size: 0.8rem;
  width: 100%;
}
.controls button:hover { background: var(--accent2); }

/* ── Mode buttons ── */
.mode-group { display: flex; gap: 0; margin-top: 0.3rem; }
.mode-group button {
  flex: 1;
  margin: 0;
  border-radius: 0;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  font-size: 0.75rem;
  padding: 0.3rem 0.2rem;
}
.mode-group button:first-child { border-radius: var(--radius) 0 0 var(--radius); }
.mode-group button:last-child { border-radius: 0 var(--radius) var(--radius) 0; }
.mode-group button.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

/* ── Search dropdown ── */
.search-wrap { position: relative; }
.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-top: none;
  border-radius: 0 0 var(--radius) var(--radius);
  max-height: 200px;
  overflow-y: auto;
  z-index: 20;
  display: none;
  box-shadow: var(--shadow);
}
.search-results .result {
  padding: 0.35rem 0.5rem;
  cursor: pointer;
  font-size: 0.78rem;
  border-bottom: 1px solid var(--border);
  line-height: 1.3;
}
.search-results .result:hover { background: #f0ece4; }
.search-results .result .rname { font-weight: bold; }
.search-results .result .rmeta { color: var(--fg2); font-size: 0.7rem; }

/* ── Tooltip ── */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: var(--fg);
  color: var(--bg);
  padding: 0.6rem 0.9rem;
  border-radius: var(--radius);
  font-size: 0.8rem;
  line-height: 1.5;
  max-width: 300px;
  z-index: 20;
  opacity: 0;
  transition: opacity 0.15s;
}
.tooltip .name { font-weight: bold; font-size: 0.9rem; }
.tooltip .dates { opacity: 0.7; }
.tooltip .place { opacity: 0.7; font-style: italic; }
.tooltip .spouse-info { margin-top: 0.25rem; opacity: 0.6; font-size: 0.75rem; }

/* ── SVG canvas ── */
svg { display: block; cursor: grab; }
svg:active { cursor: grabbing; }

/* ── Tree nodes ── */
.node rect {
  fill: var(--bg2);
  stroke-width: 2;
  cursor: pointer;
  transition: fill 0.15s;
}
.node rect:hover { fill: #f5f0e5; }
.node text { pointer-events: none; font-family: var(--font); }
.node .node-name { font-size: 11px; font-weight: bold; fill: var(--fg); }
.node .node-dates { font-size: 9px; fill: var(--fg2); }
.node .node-spouse { font-size: 8.5px; fill: var(--fg2); font-style: italic; }
.node .expand-indicator {
  font-size: 10px;
  fill: var(--accent);
  font-weight: bold;
  cursor: pointer;
}

/* ── Links ── */
.link {
  fill: none;
  stroke: var(--border);
  stroke-width: 1.5;
}
.link-highlight {
  stroke: var(--accent);
  stroke-width: 2.5;
}

/* ── Detail panel ── */
.detail-panel {
  position: fixed;
  top: 60px;
  right: -360px;
  width: 340px;
  height: calc(100vh - 60px);
  background: var(--bg2);
  border-left: 1px solid var(--border);
  box-shadow: -2px 0 8px rgba(0,0,0,0.06);
  z-index: 8;
  overflow-y: auto;
  padding: 1.2rem;
  transition: right 0.3s ease;
  font-size: 0.8rem;
}
.detail-panel.open { right: 0; }
.detail-panel h2 { font-size: 1rem; margin-bottom: 0.2rem; }
.detail-panel .close-btn {
  position: absolute;
  top: 0.8rem;
  right: 0.8rem;
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  color: var(--fg2);
  width: auto;
  margin: 0;
}
.detail-panel .close-btn:hover { color: var(--fg); }
.detail-section { margin-top: 1rem; }
.detail-section h4 { font-size: 0.8rem; color: var(--accent); margin-bottom: 0.3rem; }
.detail-section p, .detail-section li { line-height: 1.5; color: var(--fg2); }
.detail-section ul { list-style: none; padding: 0; }
.detail-section li { padding: 0.15rem 0; }
.detail-section a { color: var(--accent); cursor: pointer; text-decoration: underline; }

/* ── Loading ── */
.loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--fg2);
  font-size: 0.9rem;
  z-index: 15;
}
.loading::after {
  content: '';
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 0.5rem;
  vertical-align: middle;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Legend ── */
.legend {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 5;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0.5rem 0.8rem;
  font-size: 0.7rem;
  display: flex;
  gap: 1rem;
  box-shadow: var(--shadow);
}
.legend-item { display: flex; align-items: center; gap: 0.3rem; color: var(--fg2); }
.legend-swatch {
  width: 12px;
  height: 8px;
  border-radius: 2px;
  border: 2px solid;
  flex-shrink: 0;
}

/* ── Toolbar ── */
.toolbar {
  position: fixed;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 5;
  display: flex;
  gap: 0.3rem;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0.3rem;
  box-shadow: var(--shadow);
}
.toolbar button {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.25rem 0.6rem;
  font-size: 0.75rem;
  cursor: pointer;
  font-family: var(--font);
  color: var(--fg2);
  width: auto;
  margin: 0;
}
.toolbar button:hover { background: #f0ece4; color: var(--fg); }
</style>
</head>
<body>

<header>
  <h1><a href="/">Lack <span>Lineage</span></a></h1>
  <nav>
    <a href="/">Dashboard</a>
    <a href="/graph.html">Graph</a>
    <a href="/tree.html" class="active">Tree</a>
    <a href="/ancestry.html">Ancestry</a>
  </nav>
</header>

<!-- Controls panel -->
<div class="controls">
  <h3>Tree Explorer</h3>

  <label>Find person</label>
  <div class="search-wrap">
    <input type="text" id="search-input" placeholder="Type a name…" autocomplete="off">
    <div class="search-results" id="search-results"></div>
  </div>

  <label>Mode</label>
  <div class="mode-group">
    <button data-mode="ancestors" class="active">Ancestors</button>
    <button data-mode="descendants">Descendants</button>
    <button data-mode="both">Both</button>
  </div>

  <label>Depth <span id="depth-val">6</span></label>
  <input type="range" id="depth-range" min="1" max="14" value="6">

  <button id="btn-fit">Fit to view</button>

  <div class="stat" id="stat-info"></div>
</div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip"></div>

<!-- Detail panel -->
<div class="detail-panel" id="detail-panel">
  <button class="close-btn" id="detail-close">&times;</button>
  <div id="detail-content"></div>
</div>

<!-- Legend -->
<div class="legend">
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--male); background: #eef3f9;"></div>Male</div>
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--female); background: #f9eeee;"></div>Female</div>
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--unknown); background: #f2f2f2;"></div>Unknown</div>
</div>

<!-- Toolbar -->
<div class="toolbar">
  <button id="btn-zoomin">+</button>
  <button id="btn-zoomout">−</button>
  <button id="btn-reset">Reset</button>
  <button id="btn-collapse-all">Collapse all</button>
  <button id="btn-expand-all">Expand all</button>
</div>

<!-- Loading indicator -->
<div class="loading" id="loading" style="display:none;">Loading tree</div>

<!-- SVG canvas -->
<svg id="tree-svg"></svg>

<script src="/data/lineage-shim.js"></script>
<script>
// ── Constants ──
const NODE_W = 150, NODE_H = 56, NODE_RX = 6;
const LEVEL_GAP_H = 200;  // horizontal gap between generations
const NODE_GAP_V = 8;     // vertical gap between sibling nodes
const DEFAULT_ROOT = 1; // George l Lack — 10 gens up, deepest connected tree
const DEFAULT_DEPTH = 6;
const COLLAPSE_DEPTH = 4;  // auto-collapse beyond this depth
const MAX_VISIBLE_CHILDREN = 10; // show "…+N more" beyond this

// ── State ──
let currentRoot = DEFAULT_ROOT;
let currentMode = 'ancestors';
let currentDepth = DEFAULT_DEPTH;
let treeData = null;
let svg, g, zoom, treeSvg;

// ── Helpers ──
function sexColor(sex) {
  if (sex === 'M') return 'var(--male)';
  if (sex === 'F') return 'var(--female)';
  return 'var(--unknown)';
}
function sexFill(sex) {
  if (sex === 'M') return '#eef3f9';
  if (sex === 'F') return '#f9eeee';
  return '#f2f2f2';
}

function formatDate(d) {
  if (!d) return '?';
  // Try to extract a 4-digit year
  const m = d.match(/\b(\d{4})\b/);
  if (m) return m[1];
  return d;
}

function lifespan(node) {
  const b = formatDate(node.data.birth);
  const d = formatDate(node.data.death);
  if (b === '?' && d === '?') return '';
  if (d === '?') return `b. ${b}`;
  return `${b}–${d}`;
}

// ── Hierarchy adapters ──
// API returns { parents: [] } for ancestors, { children: [] } for descendants
// d3.hierarchy always needs .children
function adaptAncestors(node) {
  // Rename parents→children for d3.hierarchy, discard any descendant children
  if (node.parents) {
    node.children = node.parents;
    delete node.parents;
  }
  if (node.children) node.children.forEach(adaptAncestors);
  return node;
}

function adaptDescendants(node) {
  // Remove parents so d3.hierarchy only sees children
  delete node.parents;
  if (node.children) node.children.forEach(adaptDescendants);
  return node;
}

function adaptBoth(node) {
  // /api/tree returns both parents[] and children[]
  // For "both" mode, we build a dual tree: ancestors on left, descendants on right
  // We'll handle this specially in renderDualTree
  return node;
}

// ── Count descendants in hierarchy node ──
function countDescendants(node) {
  if (!node.children && !node._children) return 0;
  const kids = node.children || node._children || [];
  let total = kids.length;
  kids.forEach(c => { total += countDescendants(c); });
  return total;
}

// ── Collapse logic (operates on DATA objects, not hierarchy nodes) ──
function collapseDataAtDepth(node, maxDepth, currentD = 0) {
  if (node.children && currentD >= maxDepth) {
    node._children = node.children;
    node.children = null;
  }
  const kids = node.children || node._children || [];
  kids.forEach(c => collapseDataAtDepth(c, maxDepth, currentD + 1));
}

function expandAllData(node) {
  if (node._children) {
    node.children = node._children;
    node._children = null;
  }
  if (node.children) node.children.forEach(expandAllData);
}

function toggleNodeData(node) {
  if (node.children) {
    node._children = node.children;
    node.children = null;
  } else if (node._children) {
    node.children = node._children;
    node._children = null;
  }
}

function collapseAllData(node) {
  if (node.children && node.children.length > 0) {
    node._children = node.children;
    node.children = null;
    node._children.forEach(collapseAllData);
  }
  if (node._children) node._children.forEach(collapseAllData);
}

// ── SVG setup ──
function initSVG() {
  const el = document.getElementById('tree-svg');
  const headerH = document.querySelector('header').offsetHeight;
  el.style.width = '100%';
  el.style.height = (window.innerHeight - headerH) + 'px';

  svg = d3.select('#tree-svg');
  svg.selectAll('*').remove();

  g = svg.append('g').attr('class', 'tree-container');

  // Defs for arrow markers
  svg.append('defs').append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 0 10 10')
    .attr('refX', 10).attr('refY', 5)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,0 L10,5 L0,10 Z').attr('fill', 'var(--border)');

  zoom = d3.zoom()
    .scaleExtent([0.05, 3])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });
  svg.call(zoom);
}

// ── Fetch tree data ──
async function fetchTree(rootId, mode, depth) {
  document.getElementById('loading').style.display = 'block';
  let url;
  if (mode === 'ancestors') url = `/api/ancestors?id=${rootId}&depth=${depth}`;
  else if (mode === 'descendants') url = `/api/descendants?id=${rootId}&depth=${depth}`;
  else url = `/api/tree?root=${rootId}&depth=${depth}`;

  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    if (data.error) throw new Error(data.error);
    return data;
  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('loading').style.display = 'none';
    document.getElementById('stat-info').innerHTML = `<strong style="color:#c44">Error:</strong> ${err.message}`;
    return null;
  }
}

// ── Main render ──
async function loadAndRender() {
  updateURL();
  const raw = await fetchTree(currentRoot, currentMode, currentDepth);
  if (!raw) return;

  if (currentMode === 'both') {
    renderDualTree(raw);
  } else {
    if (currentMode === 'ancestors') adaptAncestors(raw);
    else adaptDescendants(raw);
    treeData = raw;
    renderTree(raw);
  }
  document.getElementById('loading').style.display = 'none';
}

// ── Single-direction tree render ──
function renderTree(data) {
  g.selectAll('*').remove();

  // Collapse at depth on data object (only on first render — check if already has _children)
  if (!data._collapseApplied) {
    collapseDataAtDepth(data, COLLAPSE_DEPTH);
    data._collapseApplied = true;
  }

  const root = d3.hierarchy(data, d => d.children);

  renderFromRoot(root, currentMode === 'ancestors' ? -1 : 1);
}

function renderFromRoot(root, direction) {
  // direction: -1 = ancestors (grow left), 1 = descendants (grow right)
  const treeLayout = d3.tree().nodeSize([NODE_H + NODE_GAP_V, LEVEL_GAP_H]);
  treeLayout(root);

  // Apply direction
  root.each(d => {
    d.y = d.y * direction;
  });

  // Count stats
  let nodeCount = 0, genCount = 0;
  root.each(d => {
    nodeCount++;
    genCount = Math.max(genCount, d.depth);
  });
  document.getElementById('stat-info').innerHTML =
    `<strong>${nodeCount}</strong> people &middot; <strong>${genCount}</strong> generations` +
    `<br>Root: <strong>${root.data.name || 'Unknown'}</strong>`;

  // Links
  const linkGroup = g.append('g').attr('class', 'links');
  const linkData = root.links();
  const links = linkGroup.selectAll('path').data(linkData, d => d.target.data.id);

  links.enter().append('path')
    .attr('class', 'link')
    .attr('d', d => linkPath(d, direction));

  // Nodes
  const nodeGroup = g.append('g').attr('class', 'nodes');
  const nodes = nodeGroup.selectAll('g.node')
    .data(root.descendants(), d => d.data.id)
    .enter().append('g')
    .attr('class', 'node')
    .attr('transform', d => `translate(${d.y - NODE_W/2}, ${d.x - NODE_H/2})`);

  // Node rect
  nodes.append('rect')
    .attr('width', NODE_W)
    .attr('height', NODE_H)
    .attr('rx', NODE_RX)
    .attr('stroke', d => sexColor(d.data.sex))
    .attr('fill', d => sexFill(d.data.sex));

  // Name text
  nodes.append('text')
    .attr('class', 'node-name')
    .attr('x', NODE_W / 2)
    .attr('y', 16)
    .attr('text-anchor', 'middle')
    .text(d => {
      const name = d.data.name || 'Unknown';
      return name.length > 20 ? name.slice(0, 18) + '…' : name;
    });

  // Dates text
  nodes.append('text')
    .attr('class', 'node-dates')
    .attr('x', NODE_W / 2)
    .attr('y', 30)
    .attr('text-anchor', 'middle')
    .text(d => lifespan(d));

  // Spouse text
  nodes.append('text')
    .attr('class', 'node-spouse')
    .attr('x', NODE_W / 2)
    .attr('y', 42)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.spouses || d.data.spouses.length === 0) return '';
      const sp = d.data.spouses[0];
      const name = sp.name || 'Unknown';
      return '& ' + (name.length > 18 ? name.slice(0, 16) + '…' : name);
    });

  // Expand/collapse indicator
  nodes.filter(d => d.data._children || (d.children && d.children.length > 0))
    .append('text')
    .attr('class', 'expand-indicator')
    .attr('x', direction === 1 ? NODE_W + 6 : -6)
    .attr('y', NODE_H / 2 + 4)
    .attr('text-anchor', direction === 1 ? 'start' : 'end')
    .attr('fill', 'var(--accent)')
    .attr('font-size', '10px')
    .attr('font-weight', 'bold')
    .text(d => {
      if (d.data._children) {
        return `+${d.data._children.length}`;
      }
      return '−';
    });

  // Click to expand/collapse
  nodes.on('click', function(event, d) {
    event.stopPropagation();
    if (event.shiftKey) {
      // Shift+click = re-root on this person
      currentRoot = d.data.id;
      loadAndRender();
      return;
    }
    if (d.data._children || d.children) {
      // Toggle on the DATA object so state persists across re-renders
      toggleNodeData(d.data);
      rerender(direction);
    }
  });

  // Right-click = show detail panel
  nodes.on('contextmenu', function(event, d) {
    event.preventDefault();
    showDetail(d.data.id);
  });

  // Hover tooltip
  nodes.on('mouseenter', function(event, d) {
    const tip = document.getElementById('tooltip');
    let html = `<div class="name">${d.data.name || 'Unknown'}</div>`;
    const ls = lifespan(d);
    if (ls) html += `<div class="dates">${ls}</div>`;
    if (d.data.birth) html += `<div class="place">${d.data.birth}</div>`;
    if (d.data.spouses && d.data.spouses.length > 0) {
      html += `<div class="spouse-info">Spouse: ${d.data.spouses.map(s => s.name).join(', ')}</div>`;
    }
    const hidden = d.data._children ? d.data._children.length : 0;
    if (hidden) html += `<div class="spouse-info">${hidden} hidden ${currentMode === 'ancestors' ? 'ancestors' : 'descendants'}</div>`;
    html += `<div class="spouse-info" style="margin-top:0.3rem;opacity:0.5">Click to expand/collapse<br>Shift+click to re-root<br>Right-click for details</div>`;
    tip.innerHTML = html;
    tip.style.opacity = '1';
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mousemove', function(event) {
    const tip = document.getElementById('tooltip');
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mouseleave', function() {
    document.getElementById('tooltip').style.opacity = '0';
  });

  // Highlight path on hover
  nodes.on('mouseenter.path', function(event, d) {
    const pathIds = new Set();
    let curr = d;
    while (curr) {
      pathIds.add(curr.data.id);
      curr = curr.parent;
    }
    linkGroup.selectAll('path')
      .classed('link-highlight', l => pathIds.has(l.source.data.id) && pathIds.has(l.target.data.id));
  })
  .on('mouseleave.path', function() {
    linkGroup.selectAll('path').classed('link-highlight', false);
  });

  // Save root ref for re-render on collapse toggle
  root._direction = direction;
  window._currentRoot = root;
}

// Re-render tree from treeData
function rerender(direction) {
  g.selectAll('*').remove();
  const root = d3.hierarchy(treeData, d => d.children);
  renderFromRoot(root, direction);
}

// Recursive link path generator using cubic bezier
function linkPath(d, direction) {
  const sx = d.source.y + (direction === 1 ? NODE_W/2 : -NODE_W/2);
  const sy = d.source.x;
  const tx = d.target.y + (direction === 1 ? -NODE_W/2 : NODE_W/2);
  const ty = d.target.x;
  const mx = (sx + tx) / 2;
  return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
}

// ── Dual tree (both mode) ──
function renderDualTree(data) {
  g.selectAll('*').remove();

  // Clone data for ancestor and descendant halves
  const ancestorData = JSON.parse(JSON.stringify(data));
  const descendantData = JSON.parse(JSON.stringify(data));

  // Adapt each half
  adaptAncestors(ancestorData);
  adaptDescendants(descendantData);

  // Build separate hierarchies
  collapseDataAtDepth(ancestorData, COLLAPSE_DEPTH);
  collapseDataAtDepth(descendantData, COLLAPSE_DEPTH);

  const ancestorRoot = d3.hierarchy(ancestorData, d => d.children);
  const descendantRoot = d3.hierarchy(descendantData, d => d.children);

  const treeLayout = d3.tree().nodeSize([NODE_H + NODE_GAP_V, LEVEL_GAP_H]);

  treeLayout(ancestorRoot);
  treeLayout(descendantRoot);

  // Mirror ancestors to the left
  ancestorRoot.each(d => { d.y = -d.y; });

  // Merge descendants stay positive (already correct)

  // Render both
  renderHalf(ancestorRoot, -1, 'ancestor');
  renderHalf(descendantRoot, 1, 'descendant');

  // Stats
  let totalNodes = 0;
  ancestorRoot.each(() => totalNodes++);
  descendantRoot.each(() => totalNodes++);
  totalNodes -= 1; // root counted twice
  const aGens = d3.max(ancestorRoot.descendants(), d => d.depth);
  const dGens = d3.max(descendantRoot.descendants(), d => d.depth);
  document.getElementById('stat-info').innerHTML =
    `<strong>${totalNodes}</strong> people &middot; <strong>${aGens}</strong> ancestor gens + <strong>${dGens}</strong> descendant gens` +
    `<br>Root: <strong>${data.name || 'Unknown'}</strong>`;
}

function renderHalf(root, direction, className) {
  // Links
  const linkGroup = g.append('g').attr('class', `links-${className}`);
  linkGroup.selectAll('path').data(root.links())
    .enter().append('path')
    .attr('class', 'link')
    .attr('d', d => linkPath(d, direction));

  // Nodes
  const nodeGroup = g.append('g').attr('class', `nodes-${className}`);
  const nodes = nodeGroup.selectAll('g.node')
    .data(root.descendants(), d => `${className}-${d.data.id}`)
    .enter().append('g')
    .attr('class', 'node')
    .attr('transform', d => `translate(${d.y - NODE_W/2}, ${d.x - NODE_H/2})`);

  nodes.append('rect')
    .attr('width', NODE_W)
    .attr('height', NODE_H)
    .attr('rx', NODE_RX)
    .attr('stroke', d => sexColor(d.data.sex))
    .attr('fill', d => sexFill(d.data.sex));

  nodes.append('text')
    .attr('class', 'node-name')
    .attr('x', NODE_W / 2)
    .attr('y', 16)
    .attr('text-anchor', 'middle')
    .text(d => {
      const name = d.data.name || 'Unknown';
      return name.length > 20 ? name.slice(0, 18) + '…' : name;
    });

  nodes.append('text')
    .attr('class', 'node-dates')
    .attr('x', NODE_W / 2)
    .attr('y', 30)
    .attr('text-anchor', 'middle')
    .text(d => lifespan(d));

  nodes.append('text')
    .attr('class', 'node-spouse')
    .attr('x', NODE_W / 2)
    .attr('y', 42)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.spouses || d.data.spouses.length === 0) return '';
      const sp = d.data.spouses[0];
      const name = sp.name || 'Unknown';
      return '& ' + (name.length > 18 ? name.slice(0, 16) + '…' : name);
    });

  // Expand/collapse indicator
  nodes.filter(d => d.data._children)
    .append('text')
    .attr('class', 'expand-indicator')
    .attr('x', direction === 1 ? NODE_W + 6 : -6)
    .attr('y', NODE_H / 2 + 4)
    .attr('text-anchor', direction === 1 ? 'start' : 'end')
    .attr('fill', 'var(--accent)')
    .attr('font-size', '10px')
    .attr('font-weight', 'bold')
    .text(d => `+${d.data._children.length}`);

  // Tooltip
  nodes.on('mouseenter', function(event, d) {
    const tip = document.getElementById('tooltip');
    let html = `<div class="name">${d.data.name || 'Unknown'}</div>`;
    const ls = lifespan(d);
    if (ls) html += `<div class="dates">${ls}</div>`;
    if (d.data.spouses && d.data.spouses.length > 0) {
      html += `<div class="spouse-info">Spouse: ${d.data.spouses.map(s => s.name).join(', ')}</div>`;
    }
    html += `<div class="spouse-info" style="margin-top:0.3rem;opacity:0.5">Shift+click to re-root</div>`;
    tip.innerHTML = html;
    tip.style.opacity = '1';
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mousemove', function(event) {
    const tip = document.getElementById('tooltip');
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mouseleave', function() {
    document.getElementById('tooltip').style.opacity = '0';
  });

  // Click to re-root
  nodes.on('click', function(event, d) {
    event.stopPropagation();
    currentRoot = d.data.id;
    loadAndRender();
  });

  // Right-click detail
  nodes.on('contextmenu', function(event, d) {
    event.preventDefault();
    showDetail(d.data.id);
  });
}

// ── Detail panel ──
async function showDetail(personId) {
  const panel = document.getElementById('detail-panel');
  const content = document.getElementById('detail-content');
  content.innerHTML = '<p>Loading…</p>';
  panel.classList.add('open');

  try {
    const resp = await fetch(`/api/person/${personId}`);
    const data = await resp.json();

    let html = `<h2>${data.given_name || ''} ${data.surname || ''}</h2>`;
    html += `<p style="color:var(--fg2)">ID: ${data.id}</p>`;

    // Vital info
    html += '<div class="detail-section"><h4>Vital Information</h4>';
    if (data.birth_date || data.birth_place)
      html += `<p>Born: ${data.birth_date || '?'} ${data.birth_place ? '— ' + data.birth_place : ''}</p>`;
    if (data.death_date || data.death_place)
      html += `<p>Died: ${data.death_date || '?'} ${data.death_place ? '— ' + data.death_place : ''}</p>`;
    if (data.sex) html += `<p>Sex: ${data.sex === 'M' ? 'Male' : data.sex === 'F' ? 'Female' : data.sex}</p>`;
    html += '</div>';

    // Parents
    if (data.parents && data.parents.length > 0) {
      html += '<div class="detail-section"><h4>Parents</h4><ul>';
      for (const p of data.parents) {
        html += `<li><a onclick="navigateTo(${p.id})">${p.given_name || ''} ${p.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Spouses
    if (data.spouses && data.spouses.length > 0) {
      html += '<div class="detail-section"><h4>Spouses</h4><ul>';
      for (const s of data.spouses) {
        html += `<li><a onclick="navigateTo(${s.id})">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Children
    if (data.children && data.children.length > 0) {
      html += '<div class="detail-section"><h4>Children</h4><ul>';
      for (const c of data.children) {
        html += `<li><a onclick="navigateTo(${c.id})">${c.given_name || ''} ${c.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Siblings
    if (data.siblings && data.siblings.length > 0) {
      html += '<div class="detail-section"><h4>Siblings</h4><ul>';
      for (const s of data.siblings) {
        html += `<li><a onclick="navigateTo(${s.id})">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Events
    if (data.events && data.events.length > 0) {
      html += '<div class="detail-section"><h4>Events</h4><ul>';
      for (const e of data.events) {
        html += `<li>${e.event_type}: ${e.event_date || '?'} ${e.event_place ? '— ' + e.event_place : ''}</li>`;
      }
      html += '</ul></div>';
    }

    // Re-root button
    html += `<div class="detail-section"><button onclick="navigateTo(${data.id})">View tree from this person</button></div>`;

    content.innerHTML = html;
  } catch (err) {
    content.innerHTML = `<p style="color:#c44">Error loading details: ${err.message}</p>`;
  }
}

function navigateTo(id) {
  document.getElementById('detail-panel').classList.remove('open');
  currentRoot = id;
  loadAndRender();
}

// ── Person search ──
let searchTimeout = null;
const searchInput = document.getElementById('search-input');
const searchResults = document.getElementById('search-results');

searchInput.addEventListener('input', function() {
  clearTimeout(searchTimeout);
  const q = this.value.trim();
  if (q.length < 2) {
    searchResults.style.display = 'none';
    return;
  }
  searchTimeout = setTimeout(async () => {
    try {
      const resp = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
      const people = await resp.json();
      if (people.length === 0) {
        searchResults.innerHTML = '<div class="result"><span class="rmeta">No results</span></div>';
      } else {
        searchResults.innerHTML = people.slice(0, 15).map(p => {
          const name = `${p.given_name || ''} ${p.surname || ''}`.trim() || 'Unknown';
          const dates = [p.birth_date, p.death_date].filter(Boolean).join(' – ') || 'no dates';
          return `<div class="result" data-id="${p.id}">
            <div class="rname">${name}</div>
            <div class="rmeta">${dates}</div>
          </div>`;
        }).join('');
      }
      searchResults.style.display = 'block';
    } catch (err) {
      searchResults.style.display = 'none';
    }
  }, 250);
});

searchResults.addEventListener('click', function(event) {
  const result = event.target.closest('.result');
  if (result && result.dataset.id) {
    currentRoot = parseInt(result.dataset.id);
    searchInput.value = result.querySelector('.rname').textContent;
    searchResults.style.display = 'none';
    loadAndRender();
  }
});

// Hide search results on click outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.search-wrap')) {
    searchResults.style.display = 'none';
  }
});

// ── Mode buttons ──
document.querySelectorAll('.mode-group button').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.mode-group button').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    currentMode = this.dataset.mode;
    loadAndRender();
  });
});

// ── Depth slider ──
const depthRange = document.getElementById('depth-range');
depthRange.addEventListener('input', function() {
  document.getElementById('depth-val').textContent = this.value;
});
depthRange.addEventListener('change', function() {
  currentDepth = parseInt(this.value);
  loadAndRender();
});

// ── Toolbar buttons ──
document.getElementById('btn-fit').addEventListener('click', fitToView);
document.getElementById('btn-zoomin').addEventListener('click', () => {
  svg.transition().duration(300).call(zoom.scaleBy, 1.4);
});
document.getElementById('btn-zoomout').addEventListener('click', () => {
  svg.transition().duration(300).call(zoom.scaleBy, 0.7);
});
document.getElementById('btn-reset').addEventListener('click', () => {
  currentRoot = DEFAULT_ROOT;
  currentMode = 'ancestors';
  currentDepth = DEFAULT_DEPTH;
  depthRange.value = DEFAULT_DEPTH;
  document.getElementById('depth-val').textContent = DEFAULT_DEPTH;
  document.querySelectorAll('.mode-group button').forEach(b => b.classList.remove('active'));
  document.querySelector('.mode-group button[data-mode="ancestors"]').classList.add('active');
  searchInput.value = '';
  loadAndRender();
});
document.getElementById('btn-collapse-all').addEventListener('click', () => {
  if (!treeData) return;
  collapseAllData(treeData);
  const dir = currentMode === 'ancestors' ? -1 : 1;
  rerender(dir);
});
document.getElementById('btn-expand-all').addEventListener('click', () => {
  if (!treeData) return;
  expandAllData(treeData);
  const dir = currentMode === 'ancestors' ? -1 : 1;
  rerender(dir);
});

// ── Fit to view ──
function fitToView() {
  const bounds = g.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;
  const svgEl = document.getElementById('tree-svg');
  const w = svgEl.clientWidth;
  const h = svgEl.clientHeight;
  const padding = 60;
  const scale = Math.min(
    (w - padding * 2) / bounds.width,
    (h - padding * 2) / bounds.height,
    1.5
  );
  const tx = w / 2 - (bounds.x + bounds.width / 2) * scale;
  const ty = h / 2 - (bounds.y + bounds.height / 2) * scale;
  svg.transition().duration(500)
    .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// ── Detail panel close ──
document.getElementById('detail-close').addEventListener('click', () => {
  document.getElementById('detail-panel').classList.remove('open');
});

// ── URL state ──
function updateURL() {
  const params = new URLSearchParams();
  if (currentRoot !== DEFAULT_ROOT) params.set('root', currentRoot);
  if (currentMode !== 'ancestors') params.set('mode', currentMode);
  if (currentDepth !== DEFAULT_DEPTH) params.set('depth', currentDepth);
  const qs = params.toString();
  const url = window.location.pathname + (qs ? '?' + qs : '');
  window.history.replaceState(null, '', url);
}

function readURL() {
  const params = new URLSearchParams(window.location.search);
  if (params.has('root')) currentRoot = parseInt(params.get('root'));
  if (params.has('mode')) {
    currentMode = params.get('mode');
    document.querySelectorAll('.mode-group button').forEach(b => {
      b.classList.toggle('active', b.dataset.mode === currentMode);
    });
  }
  if (params.has('depth')) {
    currentDepth = parseInt(params.get('depth'));
    depthRange.value = currentDepth;
    document.getElementById('depth-val').textContent = currentDepth;
  }
}

// ── Handle window resize ──
window.addEventListener('resize', () => {
  const headerH = document.querySelector('header').offsetHeight;
  document.getElementById('tree-svg').style.height = (window.innerHeight - headerH) + 'px';
});

// ── Init ──
readURL();
initSVG();
loadAndRender().then(() => {
  // Auto fit after initial render
  setTimeout(fitToView, 100);
});

// Handle popstate (back/forward)
window.addEventListener('popstate', () => {
  readURL();
  loadAndRender().then(() => setTimeout(fitToView, 100));
});
</script>
</body>
</html>

