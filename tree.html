<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lack Lineage — Tree</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f8f6f1;
  --bg2: #fff;
  --fg: #2a2520;
  --fg2: #6b6360;
  --accent: #8b6914;
  --accent2: #a07d2a;
  --border: #d8d2c8;
  --radius: 6px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08);
  --font: 'Georgia', 'Times New Roman', serif;
  --mono: 'Consolas', 'Monaco', monospace;
  --male: #3b82f6;
  --female: #ec4899;
  --unknown: #888;
}
html, body { height: 100%; overflow: hidden; }
body { font-family: var(--font); color: var(--fg); background: var(--bg); }

/* ── Header ── */
header {
  background: var(--fg);
  color: var(--bg);
  padding: 0.75rem 2rem;
  display: flex;
  align-items: center;
  gap: 2rem;
  z-index: 10;
}
header h1 { font-size: 1.1rem; letter-spacing: 0.05em; white-space: nowrap; }
header h1 span { font-weight: 300; opacity: 0.6; }
header h1 a { color: inherit; text-decoration: none; }
nav { display: flex; gap: 0.5rem; flex-wrap: wrap; flex: 1; }
nav a {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--bg);
  padding: 0.3rem 0.7rem;
  border-radius: var(--radius);
  font-family: var(--font);
  font-size: 0.8rem;
  text-decoration: none;
  transition: all 0.15s;
}
nav a:hover, nav a.active {
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.4);
}
nav a.active { font-weight: bold; }

/* ── Header search ── */
.header-search { position: relative; flex-shrink: 0; }
.header-search input {
  width: 200px;
  font-family: var(--font);
  font-size: 0.8rem;
  padding: 0.3rem 0.6rem;
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: var(--radius);
  background: rgba(255,255,255,0.1);
  color: var(--bg);
  outline: none;
  transition: all 0.15s;
}
.header-search input::placeholder { color: rgba(255,255,255,0.4); }
.header-search input:focus {
  background: rgba(255,255,255,0.18);
  border-color: rgba(255,255,255,0.5);
  width: 260px;
}
.header-search .search-results {
  position: absolute;
  top: 100%;
  right: 0;
  width: 300px;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 0 0 var(--radius) var(--radius);
  max-height: 250px;
  overflow-y: auto;
  z-index: 25;
  display: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
.header-search .search-results .result {
  padding: 0.4rem 0.6rem;
  cursor: pointer;
  font-size: 0.78rem;
  border-bottom: 1px solid var(--border);
  color: var(--fg);
}
.header-search .search-results .result:hover { background: #f0ece4; }
.header-search .search-results .result .rname { font-weight: bold; }
.header-search .search-results .result .rmeta { color: var(--fg2); font-size: 0.7rem; }

/* ── Options toggle ── */
.options-toggle {
  position: fixed;
  top: 60px;
  left: 1rem;
  z-index: 6;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0.35rem 0.7rem;
  font-family: var(--font);
  font-size: 0.8rem;
  cursor: pointer;
  box-shadow: var(--shadow);
  color: var(--fg2);
  display: flex;
  align-items: center;
  gap: 0.3rem;
  transition: all 0.15s;
}
.options-toggle:hover { color: var(--fg); border-color: var(--accent); }
.options-toggle .arrow { transition: transform 0.2s; font-size: 0.6rem; }
.options-toggle.open .arrow { transform: rotate(180deg); }

/* ── Controls ── */
.controls {
  position: fixed;
  top: 90px;
  left: 1rem;
  z-index: 5;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1rem;
  box-shadow: var(--shadow);
  font-size: 0.8rem;
  max-width: 260px;
  max-height: calc(100vh - 110px);
  overflow-y: auto;
  transition: transform 0.25s ease, opacity 0.25s ease;
  transform-origin: top left;
}
.controls.collapsed {
  transform: scaleY(0);
  opacity: 0;
  pointer-events: none;
}
.controls h3 { font-size: 0.85rem; margin-bottom: 0.5rem; color: var(--accent); }
.controls label { display: block; margin: 0.4rem 0 0.15rem; color: var(--fg2); font-size: 0.75rem; }
.controls select, .controls input[type="text"] {
  width: 100%;
  font-family: var(--font);
  font-size: 0.8rem;
  padding: 0.3rem 0.5rem;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: var(--bg2);
}
.controls input[type="range"] {
  width: 100%;
}
.controls .stat { margin-top: 0.6rem; color: var(--fg2); line-height: 1.4; font-size: 0.75rem; }
.controls .stat strong { color: var(--fg); }
.controls button {
  margin-top: 0.5rem;
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 0.35rem 0.7rem;
  border-radius: var(--radius);
  cursor: pointer;
  font-family: var(--font);
  font-size: 0.8rem;
  width: 100%;
}
.controls button:hover { background: var(--accent2); }

/* ── Mode buttons ── */
.mode-group { display: flex; gap: 0; margin-top: 0.3rem; }
.mode-group button {
  flex: 1;
  margin: 0;
  border-radius: 0;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  font-size: 0.75rem;
  padding: 0.3rem 0.2rem;
}
.mode-group button:first-child { border-radius: var(--radius) 0 0 var(--radius); }
.mode-group button:last-child { border-radius: 0 var(--radius) var(--radius) 0; }
.mode-group button.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

/* ── Marquee selection ── */
.marquee {
  fill: rgba(139,105,20,0.1);
  stroke: var(--accent);
  stroke-width: 1.5;
  stroke-dasharray: 5 3;
  pointer-events: none;
}

/* ── Selected nodes ── */
.node.selected rect {
  stroke-width: 3;
  filter: drop-shadow(0 0 6px rgba(139,105,20,0.4));
}
.node.dragging { opacity: 0.85; cursor: grabbing; }

/* ── Selection badge ── */
.selection-badge {
  position: fixed;
  bottom: 3.5rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 6;
  background: var(--accent);
  color: #fff;
  padding: 0.3rem 0.8rem;
  border-radius: var(--radius);
  font-size: 0.75rem;
  box-shadow: var(--shadow);
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
}
.selection-badge.visible { opacity: 1; }

/* ── Tooltip ── */
.tooltip {
  position: fixed;
  pointer-events: none;
  background: var(--fg);
  color: var(--bg);
  padding: 0.6rem 0.9rem;
  border-radius: var(--radius);
  font-size: 0.8rem;
  line-height: 1.5;
  max-width: 300px;
  z-index: 20;
  opacity: 0;
  transition: opacity 0.15s;
}
.tooltip .name { font-weight: bold; font-size: 0.9rem; }
.tooltip .dates { opacity: 0.7; }
.tooltip .place { opacity: 0.7; font-style: italic; }
.tooltip .spouse-info { margin-top: 0.25rem; opacity: 0.6; font-size: 0.75rem; }

/* ── SVG canvas ── */
svg { display: block; cursor: grab; }
svg:active { cursor: grabbing; }

/* ── Tree nodes ── */
.node rect {
  fill: var(--bg2);
  stroke-width: 2;
  cursor: pointer;
  transition: fill 0.15s, stroke-width 0.15s;
}
.node rect:hover { fill: #f5f0e5; stroke-width: 2.5; }
.node.root-node rect { stroke-width: 3; filter: drop-shadow(0 0 4px rgba(139,105,20,0.25)); }
.node text { pointer-events: none; font-family: var(--font); }
.node .node-name { font-size: 11px; font-weight: bold; fill: var(--fg); }
.node .node-dates { font-size: 9px; fill: var(--fg2); }
.node .node-place { font-size: 8px; fill: var(--fg2); font-style: italic; opacity: 0.7; }
.node .node-spouse { font-size: 8.5px; fill: var(--fg2); font-style: italic; }
.node .expand-indicator {
  font-size: 10px;
  fill: var(--accent);
  font-weight: bold;
  cursor: pointer;
}
.node .confidence-dot {
  pointer-events: none;
}

/* ── Links ── */
.link {
  fill: none;
  stroke: var(--border);
  stroke-width: 1.5;
  transition: stroke 0.2s, stroke-width 0.2s;
}
.link-highlight {
  stroke: var(--accent);
  stroke-width: 2.5;
}

/* ── Confidence legend ── */
.conf-legend {
  display: flex;
  gap: 0.6rem;
  margin-top: 0.6rem;
  flex-wrap: wrap;
}
.conf-legend-item {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.68rem;
  color: var(--fg2);
}
.conf-swatch {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* ── Detail panel ── */
.detail-panel {
  position: fixed;
  top: 60px;
  right: -360px;
  width: 340px;
  height: calc(100vh - 60px);
  background: var(--bg2);
  border-left: 1px solid var(--border);
  box-shadow: -2px 0 8px rgba(0,0,0,0.06);
  z-index: 8;
  overflow-y: auto;
  padding: 1.2rem;
  transition: right 0.3s ease;
  font-size: 0.8rem;
}
.detail-panel.open { right: 0; }
.detail-panel h2 { font-size: 1rem; margin-bottom: 0.2rem; }
.detail-panel .close-btn {
  position: absolute;
  top: 0.8rem;
  right: 0.8rem;
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  color: var(--fg2);
  width: auto;
  margin: 0;
}
.detail-panel .close-btn:hover { color: var(--fg); }
.detail-section { margin-top: 1rem; }
.detail-section h4 { font-size: 0.8rem; color: var(--accent); margin-bottom: 0.3rem; }
.detail-section p, .detail-section li { line-height: 1.5; color: var(--fg2); }
.detail-section ul { list-style: none; padding: 0; }
.detail-section li { padding: 0.15rem 0; }
.detail-section a { color: var(--accent); cursor: pointer; text-decoration: underline; }

/* ── Loading ── */
.loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--fg2);
  font-size: 0.9rem;
  z-index: 15;
}
.loading::after {
  content: '';
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 0.5rem;
  vertical-align: middle;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Legend ── */
.legend {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 5;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0.5rem 0.8rem;
  font-size: 0.7rem;
  display: flex;
  gap: 1rem;
  box-shadow: var(--shadow);
}
.legend-item { display: flex; align-items: center; gap: 0.3rem; color: var(--fg2); }
.legend-swatch {
  width: 12px;
  height: 8px;
  border-radius: 2px;
  border: 2px solid;
  flex-shrink: 0;
}

/* ── Toolbar ── */
.toolbar {
  position: fixed;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 5;
  display: flex;
  gap: 0.3rem;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 0.3rem;
  box-shadow: var(--shadow);
}
.toolbar button {
  background: none;
  border: 1px solid var(--border);
  border-radius: 3px;
  padding: 0.25rem 0.6rem;
  font-size: 0.75rem;
  cursor: pointer;
  font-family: var(--font);
  color: var(--fg2);
  width: auto;
  margin: 0;
}
.toolbar button:hover { background: #f0ece4; color: var(--fg); }
</style>
</head>
<body>

<header>
  <h1><a href="/">Lack <span>Lineage</span></a></h1>
  <nav>
    <a href="/">Dashboard</a>
    <a href="/search.html">Search</a>
    <a href="/research.html">Research</a>
    <a href="/graph.html">Graph</a>
    <a href="/tree.html" class="active">Tree</a>
  </nav>
  <div class="header-search">
    <input type="text" id="search-input" placeholder="Find person… (/)" autocomplete="off">
    <div class="search-results" id="search-results"></div>
  </div>
</header>

<!-- Options toggle -->
<button class="options-toggle" id="options-toggle">
  <span class="arrow">▼</span> Options
</button>

<!-- Controls panel -->
<div class="controls collapsed" id="controls-panel">
  <h3>Tree Explorer</h3>

  <label>Mode</label>
  <div class="mode-group">
    <button data-mode="ancestors" class="active">Ancestors</button>
    <button data-mode="descendants">Descendants</button>
    <button data-mode="both">Both</button>
  </div>

  <label>Depth <span id="depth-val">6</span></label>
  <input type="range" id="depth-range" min="1" max="14" value="6">

  <button id="btn-fit">Fit to view</button>

  <div class="stat" id="stat-info"></div>

  <label>Lines</label>
  <div class="mode-group">
    <button data-line="curved" class="active">Curved</button>
    <button data-line="straight">Straight</button>
    <button data-line="step">Step</button>
  </div>

  <div class="conf-legend">
    <div class="conf-legend-item"><span class="conf-swatch" style="background:#2d9a2d"></span>High</div>
    <div class="conf-legend-item"><span class="conf-swatch" style="background:#c9a100"></span>Medium</div>
    <div class="conf-legend-item"><span class="conf-swatch" style="background:#d47a1a"></span>Low</div>
    <div class="conf-legend-item"><span class="conf-swatch" style="background:#c44"></span>Speculative</div>
  </div>
</div>

<!-- Selection badge -->
<div class="selection-badge" id="selection-badge"></div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip"></div>

<!-- Detail panel -->
<div class="detail-panel" id="detail-panel">
  <button class="close-btn" id="detail-close">&times;</button>
  <div id="detail-content"></div>
</div>

<!-- Legend -->
<div class="legend">
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--male); background: #eef3f9;"></div>Male</div>
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--female); background: #f9eeee;"></div>Female</div>
  <div class="legend-item"><div class="legend-swatch" style="border-color: var(--unknown); background: #f2f2f2;"></div>Unknown</div>
</div>

<!-- Toolbar -->
<div class="toolbar">
  <button id="btn-zoomin">+</button>
  <button id="btn-zoomout">−</button>
  <button id="btn-reset">Reset</button>
  <button id="btn-collapse-all">Collapse all</button>
  <button id="btn-expand-all">Expand all</button>
  <button id="btn-download-png" title="Save as PNG">&#128247; PNG</button>
</div>

<!-- Loading indicator -->
<div class="loading" id="loading" style="display:none;">Loading tree</div>

<!-- SVG canvas -->
<svg id="tree-svg"></svg>

<script src="/data/lineage-shim.js"></script>
<script>
// ── Constants ──
const NODE_W = 160, NODE_H = 60, NODE_RX = 6;
const LEVEL_GAP_H = 200;  // horizontal gap between generations
const NODE_GAP_V = 8;     // vertical gap between sibling nodes
const DEFAULT_ROOT = 1; // George l Lack — 10 gens up, deepest connected tree
const DEFAULT_DEPTH = 6;
const COLLAPSE_DEPTH = 4;  // auto-collapse beyond this depth
const MAX_VISIBLE_CHILDREN = 10; // show "…+N more" beyond this

// ── State ──
let currentRoot = DEFAULT_ROOT;
let currentMode = 'ancestors';
let currentDepth = DEFAULT_DEPTH;
let currentLineStyle = 'curved';
let treeData = null;
let svg, g, zoom, treeSvg;
let selectedNodes = new Set();
let dragState = null;
let marqueeState = null;
let allRenderedNodes = [];  // keeps track of all rendered d3 hierarchy nodes

// ── Helpers ──
function sexColor(sex) {
  if (sex === 'M') return 'var(--male)';
  if (sex === 'F') return 'var(--female)';
  return 'var(--unknown)';
}
function sexFill(sex) {
  if (sex === 'M') return '#eff6ff';
  if (sex === 'F') return '#fdf2f8';
  return '#f2f2f2';
}

function formatDate(d) {
  if (!d) return '?';
  // Try to extract a 4-digit year
  const m = d.match(/\b(\d{4})\b/);
  if (m) return m[1];
  return d;
}

function lifespan(node) {
  const b = formatDate(node.data.birth);
  const d = formatDate(node.data.death);
  if (b === '?' && d === '?') return '';
  if (d === '?') return `b. ${b}`;
  return `${b}–${d}`;
}

// ── Hierarchy adapters ──
// API returns { parents: [] } for ancestors, { children: [] } for descendants
// d3.hierarchy always needs .children
function adaptAncestors(node) {
  // Rename parents→children for d3.hierarchy, discard any descendant children
  if (node.parents) {
    node.children = node.parents;
    delete node.parents;
  }
  if (node.children) node.children.forEach(adaptAncestors);
  return node;
}

function adaptDescendants(node) {
  // Remove parents so d3.hierarchy only sees children
  delete node.parents;
  if (node.children) node.children.forEach(adaptDescendants);
  return node;
}

function adaptBoth(node) {
  // /api/tree returns both parents[] and children[]
  // For "both" mode, we build a dual tree: ancestors on left, descendants on right
  // We'll handle this specially in renderDualTree
  return node;
}

// ── Count descendants in hierarchy node ──
function countDescendants(node) {
  if (!node.children && !node._children) return 0;
  const kids = node.children || node._children || [];
  let total = kids.length;
  kids.forEach(c => { total += countDescendants(c); });
  return total;
}

// ── Collapse logic (operates on DATA objects, not hierarchy nodes) ──
function collapseDataAtDepth(node, maxDepth, currentD = 0) {
  if (node.children && currentD >= maxDepth) {
    node._children = node.children;
    node.children = null;
  }
  const kids = node.children || node._children || [];
  kids.forEach(c => collapseDataAtDepth(c, maxDepth, currentD + 1));
}

function expandAllData(node) {
  if (node._children) {
    node.children = node._children;
    node._children = null;
  }
  if (node.children) node.children.forEach(expandAllData);
}

function toggleNodeData(node) {
  if (node.children) {
    node._children = node.children;
    node.children = null;
  } else if (node._children) {
    node.children = node._children;
    node._children = null;
  }
}

function collapseAllData(node) {
  if (node.children && node.children.length > 0) {
    node._children = node.children;
    node.children = null;
    node._children.forEach(collapseAllData);
  }
  if (node._children) node._children.forEach(collapseAllData);
}

// ── SVG setup ──
function initSVG() {
  const el = document.getElementById('tree-svg');
  const headerH = document.querySelector('header').offsetHeight;
  el.style.width = '100%';
  el.style.height = (window.innerHeight - headerH) + 'px';

  svg = d3.select('#tree-svg');
  svg.selectAll('*').remove();

  g = svg.append('g').attr('class', 'tree-container');

  // Defs for arrow markers
  svg.append('defs').append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 0 10 10')
    .attr('refX', 10).attr('refY', 5)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,0 L10,5 L0,10 Z').attr('fill', 'var(--border)');

  zoom = d3.zoom()
    .scaleExtent([0.05, 3])
    .filter(event => {
      // Allow scroll-wheel zoom always; block left-click pan (we use it for marquee)
      if (event.type === 'wheel') return true;
      if (event.type === 'mousedown' && event.button === 0) return false;
      // Middle-click pan is fine
      return !event.ctrlKey;
    })
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });
  svg.call(zoom);
  // Allow middle-click drag to pan
  svg.on('mousedown.zoom', function(event) {
    if (event.button === 1) {
      event.preventDefault();
    }
  });

  // ── Marquee rectangle selection (left-click drag on background) ──
  svg.on('mousedown.marquee', function(event) {
    if (event.button !== 0) return;
    // Only start marquee if clicking on empty SVG background
    if (event.target !== svg.node() && event.target.tagName !== 'svg') return;
    event.preventDefault();
    const pt = getSVGPoint(event);
    const rect = g.append('rect').attr('class', 'marquee')
      .attr('x', pt.x).attr('y', pt.y).attr('width', 0).attr('height', 0);
    marqueeState = { rect, sx: pt.x, sy: pt.y };
  });
  svg.on('mousemove.marquee', function(event) {
    if (!marqueeState) return;
    event.preventDefault();
    const pt = getSVGPoint(event);
    const x = Math.min(marqueeState.sx, pt.x);
    const y = Math.min(marqueeState.sy, pt.y);
    const w = Math.abs(pt.x - marqueeState.sx);
    const h = Math.abs(pt.y - marqueeState.sy);
    marqueeState.rect.attr('x', x).attr('y', y).attr('width', w).attr('height', h);
  });
  svg.on('mouseup.marquee', function(event) {
    if (!marqueeState) return;
    const pt = getSVGPoint(event);
    const x1 = Math.min(marqueeState.sx, pt.x);
    const y1 = Math.min(marqueeState.sy, pt.y);
    const x2 = Math.max(marqueeState.sx, pt.x);
    const y2 = Math.max(marqueeState.sy, pt.y);
    marqueeState.rect.remove();
    marqueeState = null;

    // Only select if dragged a meaningful distance
    if (Math.abs(x2 - x1) < 5 && Math.abs(y2 - y1) < 5) return;

    if (!event.ctrlKey && !event.metaKey) selectedNodes.clear();
    for (const nd of allRenderedNodes) {
      const cx = nd.y;  // node center x (d3 tree uses y for horizontal)
      const cy = nd.x;  // node center y
      if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) {
        selectedNodes.add(nd.data.id);
      }
    }
    updateSelectionVisuals();
  });

  // Deselect on background click (only if no drag happened)
  svg.on('click.deselect', function(event) {
    if (event.target === svg.node() || event.target.tagName === 'svg') {
      if (selectedNodes.size > 0) {
        selectedNodes.clear();
        updateSelectionVisuals();
      }
    }
  });
}

// ── SVG coordinate helper ──
function getSVGPoint(event) {
  const pt = svg.node().createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  const ctm = g.node().getScreenCTM();
  return ctm ? pt.matrixTransform(ctm.inverse()) : pt;
}

// ── Selection visuals ──
function updateSelectionVisuals() {
  g.selectAll('.node').each(function(d) {
    d3.select(this).classed('selected', selectedNodes.has(d.data.id));
  });
  const badge = document.getElementById('selection-badge');
  if (selectedNodes.size > 0) {
    badge.textContent = `${selectedNodes.size} selected`;
    badge.classList.add('visible');
  } else {
    badge.classList.remove('visible');
  }
}

// ── Fetch tree data ──
async function fetchTree(rootId, mode, depth) {
  document.getElementById('loading').style.display = 'block';
  let url;
  if (mode === 'ancestors') url = `/api/ancestors?id=${rootId}&depth=${depth}`;
  else if (mode === 'descendants') url = `/api/descendants?id=${rootId}&depth=${depth}`;
  else url = `/api/tree?root=${rootId}&depth=${depth}`;

  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    if (data.error) throw new Error(data.error);
    return data;
  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('loading').style.display = 'none';
    document.getElementById('stat-info').innerHTML = `<strong style="color:#c44">Error:</strong> ${err.message}`;
    return null;
  }
}

// ── Main render ──
async function loadAndRender() {
  updateURL();
  const raw = await fetchTree(currentRoot, currentMode, currentDepth);
  if (!raw) return;

  if (currentMode === 'both') {
    renderDualTree(raw);
  } else {
    if (currentMode === 'ancestors') adaptAncestors(raw);
    else adaptDescendants(raw);
    treeData = raw;
    renderTree(raw);
  }
  document.getElementById('loading').style.display = 'none';
}

// ── Single-direction tree render ──
function renderTree(data) {
  g.selectAll('*').remove();

  // Collapse at depth on data object (only on first render — check if already has _children)
  if (!data._collapseApplied) {
    collapseDataAtDepth(data, COLLAPSE_DEPTH);
    data._collapseApplied = true;
  }

  const root = d3.hierarchy(data, d => d.children);

  renderFromRoot(root, currentMode === 'ancestors' ? -1 : 1);
}

function renderFromRoot(root, direction) {
  // direction: -1 = ancestors (grow left), 1 = descendants (grow right)
  const treeLayout = d3.tree().nodeSize([NODE_H + NODE_GAP_V, LEVEL_GAP_H]);
  treeLayout(root);

  // Apply direction
  root.each(d => {
    d.y = d.y * direction;
  });

  // Count stats
  let nodeCount = 0, genCount = 0;
  root.each(d => {
    nodeCount++;
    genCount = Math.max(genCount, d.depth);
  });
  document.getElementById('stat-info').innerHTML =
    `<strong>${nodeCount}</strong> people &middot; <strong>${genCount}</strong> generations` +
    `<br>Root: <strong>${root.data.name || 'Unknown'}</strong>`;

  // Links
  const linkGroup = g.append('g').attr('class', 'links');
  const linkData = root.links();
  const links = linkGroup.selectAll('path').data(linkData, d => d.target.data.id);

  links.enter().append('path')
    .attr('class', 'link')
    .attr('d', d => linkPath(d, direction));

  // Nodes
  const nodeGroup = g.append('g').attr('class', 'nodes');
  const nodes = nodeGroup.selectAll('g.node')
    .data(root.descendants(), d => d.data.id)
    .enter().append('g')
    .attr('class', 'node')
    .attr('transform', d => `translate(${d.y - NODE_W/2}, ${d.x - NODE_H/2})`);

  // Node rect
  nodes.append('rect')
    .attr('width', NODE_W)
    .attr('height', NODE_H)
    .attr('rx', NODE_RX)
    .attr('stroke', d => sexColor(d.data.sex))
    .attr('fill', d => sexFill(d.data.sex));

  // Root node highlight
  nodes.filter(d => d.depth === 0).classed('root-node', true);

  // Confidence dot (top-right corner)
  nodes.append('circle')
    .attr('class', 'confidence-dot')
    .attr('cx', NODE_W - 8)
    .attr('cy', 8)
    .attr('r', 3.5)
    .attr('fill', d => {
      const tier = d.data.confidence_tier || 'speculative';
      if (tier === 'high') return '#2d9a2d';
      if (tier === 'medium') return '#c9a100';
      if (tier === 'low') return '#d47a1a';
      return '#c44';
    })
    .attr('opacity', 0.8);

  // Name text
  nodes.append('text')
    .attr('class', 'node-name')
    .attr('x', NODE_W / 2)
    .attr('y', 15)
    .attr('text-anchor', 'middle')
    .text(d => {
      const name = d.data.name || 'Unknown';
      return name.length > 20 ? name.slice(0, 18) + '…' : name;
    });

  // Dates text
  nodes.append('text')
    .attr('class', 'node-dates')
    .attr('x', NODE_W / 2)
    .attr('y', 27)
    .attr('text-anchor', 'middle')
    .text(d => lifespan(d));

  // Birthplace text (short)
  nodes.append('text')
    .attr('class', 'node-place')
    .attr('x', NODE_W / 2)
    .attr('y', 38)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.birth_place) return '';
      const place = d.data.birth_place;
      // Show just city/state or first 22 chars
      const parts = place.split(',').map(s => s.trim());
      const short = parts.length >= 2 ? parts[0] + ', ' + parts[1] : parts[0];
      return short.length > 22 ? short.slice(0, 20) + '…' : short;
    });

  // Spouse text
  nodes.append('text')
    .attr('class', 'node-spouse')
    .attr('x', NODE_W / 2)
    .attr('y', 49)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.spouses || d.data.spouses.length === 0) return '';
      const sp = d.data.spouses[0];
      const name = sp.name || 'Unknown';
      return '& ' + (name.length > 18 ? name.slice(0, 16) + '…' : name);
    });

  // Expand/collapse indicator
  nodes.filter(d => d.data._children || (d.children && d.children.length > 0))
    .append('text')
    .attr('class', 'expand-indicator')
    .attr('x', direction === 1 ? NODE_W + 6 : -6)
    .attr('y', NODE_H / 2 + 4)
    .attr('text-anchor', direction === 1 ? 'start' : 'end')
    .attr('fill', 'var(--accent)')
    .attr('font-size', '10px')
    .attr('font-weight', 'bold')
    .text(d => {
      if (d.data._children) {
        return `+${d.data._children.length}`;
      }
      return '−';
    });

  // Store rendered nodes for marquee selection
  allRenderedNodes = root.descendants();

  // ── Drag behaviour ──
  nodes.call(d3.drag()
    .on('start', function(event, d) {
      event.sourceEvent.stopPropagation();
      if (!selectedNodes.has(d.data.id)) {
        if (!event.sourceEvent.ctrlKey && !event.sourceEvent.metaKey) selectedNodes.clear();
        selectedNodes.add(d.data.id);
        updateSelectionVisuals();
      }
      const pt = getSVGPoint(event.sourceEvent);
      dragState = { starts: new Map(), sx: pt.x, sy: pt.y };
      for (const nd of allRenderedNodes) {
        if (selectedNodes.has(nd.data.id)) {
          dragState.starts.set(nd.data.id, { x: nd.x, y: nd.y });
        }
      }
      for (const id of selectedNodes) {
        g.selectAll('.node').filter(dd => dd.data.id === id).classed('dragging', true);
      }
    })
    .on('drag', function(event, d) {
      if (!dragState) return;
      const pt = getSVGPoint(event.sourceEvent);
      const dx = pt.x - dragState.sx;
      const dy = pt.y - dragState.sy;
      for (const [id, start] of dragState.starts) {
        const nd = allRenderedNodes.find(n => n.data.id === id);
        if (!nd) continue;
        nd.x = start.x + dy;  // d3 tree: x is vertical
        nd.y = start.y + dx;  // d3 tree: y is horizontal
        g.selectAll('.node').filter(dd => dd.data.id === id)
          .attr('transform', `translate(${nd.y - NODE_W/2}, ${nd.x - NODE_H/2})`);
      }
      // Update links
      linkGroup.selectAll('path').data(linkData)
        .attr('d', dd => linkPath(dd, direction));
    })
    .on('end', function(event, d) {
      dragState = null;
      g.selectAll('.node.dragging').classed('dragging', false);
    })
  );

  // Click to expand/collapse or select
  nodes.on('click', function(event, d) {
    event.stopPropagation();
    if (event.shiftKey) {
      // Shift+click = re-root on this person
      currentRoot = d.data.id;
      loadAndRender();
      return;
    }
    if (event.ctrlKey || event.metaKey) {
      // Ctrl+click = toggle selection
      if (selectedNodes.has(d.data.id)) selectedNodes.delete(d.data.id);
      else selectedNodes.add(d.data.id);
      updateSelectionVisuals();
      return;
    }
    if (d.data._children || d.children) {
      // Toggle on the DATA object so state persists across re-renders
      toggleNodeData(d.data);
      rerender(direction);
    }
  });

  // Right-click = show detail panel
  nodes.on('contextmenu', function(event, d) {
    event.preventDefault();
    showDetail(d.data.id);
  });

  // Hover tooltip
  nodes.on('mouseenter', function(event, d) {
    const tip = document.getElementById('tooltip');
    let html = `<div class="name">${d.data.name || 'Unknown'}</div>`;
    const ls = lifespan(d);
    if (ls) html += `<div class="dates">${ls}</div>`;
    if (d.data.birth_place) html += `<div class="place">${d.data.birth_place}</div>`;
    if (d.data.spouses && d.data.spouses.length > 0) {
      html += `<div class="spouse-info">Spouse: ${d.data.spouses.map(s => s.name).join(', ')}</div>`;
    }
    const hidden = d.data._children ? d.data._children.length : 0;
    if (hidden) html += `<div class="spouse-info">${hidden} hidden ${currentMode === 'ancestors' ? 'ancestors' : 'descendants'}</div>`;
    html += `<div class="spouse-info" style="margin-top:0.3rem;opacity:0.5">Click to expand · Ctrl+click to select<br>Shift+click to re-root · Right-click for details<br>Drag to move selected nodes</div>`;
    tip.innerHTML = html;
    tip.style.opacity = '1';
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mousemove', function(event) {
    const tip = document.getElementById('tooltip');
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mouseleave', function() {
    document.getElementById('tooltip').style.opacity = '0';
  });

  // Highlight path on hover
  nodes.on('mouseenter.path', function(event, d) {
    const pathIds = new Set();
    let curr = d;
    while (curr) {
      pathIds.add(curr.data.id);
      curr = curr.parent;
    }
    linkGroup.selectAll('path')
      .classed('link-highlight', l => pathIds.has(l.source.data.id) && pathIds.has(l.target.data.id));
  })
  .on('mouseleave.path', function() {
    linkGroup.selectAll('path').classed('link-highlight', false);
  });

  // Apply selection visuals if any nodes are still selected
  updateSelectionVisuals();

  // Save root ref for re-render on collapse toggle
  root._direction = direction;
  window._currentRoot = root;
}

// Re-render tree from treeData with smooth crossfade
function rerender(direction) {
  g.transition().duration(120).style('opacity', 0).on('end', () => {
    g.selectAll('*').remove();
    const root = d3.hierarchy(treeData, d => d.children);
    renderFromRoot(root, direction);
    g.style('opacity', 0).transition().duration(200).style('opacity', 1);
  });
}

// Link path generator — supports curved, straight, step
function linkPath(d, direction) {
  const sx = d.source.y + (direction === 1 ? NODE_W/2 : -NODE_W/2);
  const sy = d.source.x;
  const tx = d.target.y + (direction === 1 ? -NODE_W/2 : NODE_W/2);
  const ty = d.target.x;
  if (currentLineStyle === 'straight') {
    return `M${sx},${sy} L${tx},${ty}`;
  }
  if (currentLineStyle === 'step') {
    const mx = (sx + tx) / 2;
    return `M${sx},${sy} H${mx} V${ty} H${tx}`;
  }
  // curved (default)
  const mx = (sx + tx) / 2;
  return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
}

// ── Dual tree (both mode) ──
function renderDualTree(data) {
  g.selectAll('*').remove();

  // Clone data for ancestor and descendant halves
  const ancestorData = JSON.parse(JSON.stringify(data));
  const descendantData = JSON.parse(JSON.stringify(data));

  // Adapt each half
  adaptAncestors(ancestorData);
  adaptDescendants(descendantData);

  // Build separate hierarchies
  collapseDataAtDepth(ancestorData, COLLAPSE_DEPTH);
  collapseDataAtDepth(descendantData, COLLAPSE_DEPTH);

  const ancestorRoot = d3.hierarchy(ancestorData, d => d.children);
  const descendantRoot = d3.hierarchy(descendantData, d => d.children);

  const treeLayout = d3.tree().nodeSize([NODE_H + NODE_GAP_V, LEVEL_GAP_H]);

  treeLayout(ancestorRoot);
  treeLayout(descendantRoot);

  // Mirror ancestors to the left
  ancestorRoot.each(d => { d.y = -d.y; });

  // Merge descendants stay positive (already correct)

  // Render both
  renderHalf(ancestorRoot, -1, 'ancestor');
  renderHalf(descendantRoot, 1, 'descendant');

  // Store all rendered nodes for marquee
  allRenderedNodes = [...ancestorRoot.descendants(), ...descendantRoot.descendants()];

  // Stats
  let totalNodes = 0;
  ancestorRoot.each(() => totalNodes++);
  descendantRoot.each(() => totalNodes++);
  totalNodes -= 1; // root counted twice
  const aGens = d3.max(ancestorRoot.descendants(), d => d.depth);
  const dGens = d3.max(descendantRoot.descendants(), d => d.depth);
  document.getElementById('stat-info').innerHTML =
    `<strong>${totalNodes}</strong> people &middot; <strong>${aGens}</strong> ancestor gens + <strong>${dGens}</strong> descendant gens` +
    `<br>Root: <strong>${data.name || 'Unknown'}</strong>`;
}

function renderHalf(root, direction, className) {
  // Links
  const linkGroup = g.append('g').attr('class', `links-${className}`);
  linkGroup.selectAll('path').data(root.links())
    .enter().append('path')
    .attr('class', 'link')
    .attr('d', d => linkPath(d, direction));

  // Nodes
  const nodeGroup = g.append('g').attr('class', `nodes-${className}`);
  const nodes = nodeGroup.selectAll('g.node')
    .data(root.descendants(), d => `${className}-${d.data.id}`)
    .enter().append('g')
    .attr('class', 'node')
    .attr('transform', d => `translate(${d.y - NODE_W/2}, ${d.x - NODE_H/2})`);

  nodes.append('rect')
    .attr('width', NODE_W)
    .attr('height', NODE_H)
    .attr('rx', NODE_RX)
    .attr('stroke', d => sexColor(d.data.sex))
    .attr('fill', d => sexFill(d.data.sex));

  // Root node highlight (depth 0 in either half)
  nodes.filter(d => d.depth === 0).classed('root-node', true);

  // Confidence dot
  nodes.append('circle')
    .attr('class', 'confidence-dot')
    .attr('cx', NODE_W - 8)
    .attr('cy', 8)
    .attr('r', 3.5)
    .attr('fill', d => {
      const tier = d.data.confidence_tier || 'speculative';
      if (tier === 'high') return '#2d9a2d';
      if (tier === 'medium') return '#c9a100';
      if (tier === 'low') return '#d47a1a';
      return '#c44';
    })
    .attr('opacity', 0.8);

  nodes.append('text')
    .attr('class', 'node-name')
    .attr('x', NODE_W / 2)
    .attr('y', 15)
    .attr('text-anchor', 'middle')
    .text(d => {
      const name = d.data.name || 'Unknown';
      return name.length > 20 ? name.slice(0, 18) + '…' : name;
    });

  nodes.append('text')
    .attr('class', 'node-dates')
    .attr('x', NODE_W / 2)
    .attr('y', 27)
    .attr('text-anchor', 'middle')
    .text(d => lifespan(d));

  // Birthplace
  nodes.append('text')
    .attr('class', 'node-place')
    .attr('x', NODE_W / 2)
    .attr('y', 38)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.birth_place) return '';
      const parts = d.data.birth_place.split(',').map(s => s.trim());
      const short = parts.length >= 2 ? parts[0] + ', ' + parts[1] : parts[0];
      return short.length > 22 ? short.slice(0, 20) + '…' : short;
    });

  nodes.append('text')
    .attr('class', 'node-spouse')
    .attr('x', NODE_W / 2)
    .attr('y', 49)
    .attr('text-anchor', 'middle')
    .text(d => {
      if (!d.data.spouses || d.data.spouses.length === 0) return '';
      const sp = d.data.spouses[0];
      const name = sp.name || 'Unknown';
      return '& ' + (name.length > 18 ? name.slice(0, 16) + '…' : name);
    });

  // Expand/collapse indicator
  nodes.filter(d => d.data._children)
    .append('text')
    .attr('class', 'expand-indicator')
    .attr('x', direction === 1 ? NODE_W + 6 : -6)
    .attr('y', NODE_H / 2 + 4)
    .attr('text-anchor', direction === 1 ? 'start' : 'end')
    .attr('fill', 'var(--accent)')
    .attr('font-size', '10px')
    .attr('font-weight', 'bold')
    .text(d => `+${d.data._children.length}`);

  // Tooltip
  nodes.on('mouseenter', function(event, d) {
    const tip = document.getElementById('tooltip');
    let html = `<div class="name">${d.data.name || 'Unknown'}</div>`;
    const ls = lifespan(d);
    if (ls) html += `<div class="dates">${ls}</div>`;
    if (d.data.birth_place) html += `<div class="place">${d.data.birth_place}</div>`;
    if (d.data.spouses && d.data.spouses.length > 0) {
      html += `<div class="spouse-info">Spouse: ${d.data.spouses.map(s => s.name).join(', ')}</div>`;
    }
    const hidden = d.data._children ? d.data._children.length : 0;
    if (hidden) html += `<div class="spouse-info">${hidden} hidden nodes</div>`;
    html += `<div class="spouse-info" style="margin-top:0.3rem;opacity:0.5">Ctrl+click to select · Drag to move<br>Shift+click to re-root · Right-click for details</div>`;
    tip.innerHTML = html;
    tip.style.opacity = '1';
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mousemove', function(event) {
    const tip = document.getElementById('tooltip');
    tip.style.left = (event.clientX + 15) + 'px';
    tip.style.top = (event.clientY - 10) + 'px';
  })
  .on('mouseleave', function() {
    document.getElementById('tooltip').style.opacity = '0';
  });

  // ── Drag behaviour ──
  const linkData = root.links();
  nodes.call(d3.drag()
    .on('start', function(event, d) {
      event.sourceEvent.stopPropagation();
      if (!selectedNodes.has(d.data.id)) {
        if (!event.sourceEvent.ctrlKey && !event.sourceEvent.metaKey) selectedNodes.clear();
        selectedNodes.add(d.data.id);
        updateSelectionVisuals();
      }
      const pt = getSVGPoint(event.sourceEvent);
      dragState = { starts: new Map(), sx: pt.x, sy: pt.y };
      for (const nd of allRenderedNodes) {
        if (selectedNodes.has(nd.data.id)) {
          dragState.starts.set(nd.data.id, { x: nd.x, y: nd.y });
        }
      }
      for (const id of selectedNodes) {
        g.selectAll('.node').filter(dd => dd.data.id === id).classed('dragging', true);
      }
    })
    .on('drag', function(event, d) {
      if (!dragState) return;
      const pt = getSVGPoint(event.sourceEvent);
      const dx = pt.x - dragState.sx;
      const dy = pt.y - dragState.sy;
      for (const [id, start] of dragState.starts) {
        const nd = allRenderedNodes.find(n => n.data.id === id);
        if (!nd) continue;
        nd.x = start.x + dy;
        nd.y = start.y + dx;
        g.selectAll('.node').filter(dd => dd.data.id === id)
          .attr('transform', `translate(${nd.y - NODE_W/2}, ${nd.x - NODE_H/2})`);
      }
      // Update all links in both halves
      g.selectAll('.link').each(function() {
        const pathEl = d3.select(this);
        const linkDatum = pathEl.datum();
        if (linkDatum) {
          const dir = linkDatum.source.y <= 0 ? -1 : 1;
          pathEl.attr('d', linkPath(linkDatum, dir));
        }
      });
    })
    .on('end', function(event, d) {
      dragState = null;
      g.selectAll('.node.dragging').classed('dragging', false);
    })
  );

  // Click to select or re-root
  nodes.on('click', function(event, d) {
    event.stopPropagation();
    if (event.ctrlKey || event.metaKey) {
      if (selectedNodes.has(d.data.id)) selectedNodes.delete(d.data.id);
      else selectedNodes.add(d.data.id);
      updateSelectionVisuals();
      return;
    }
    if (event.shiftKey) {
      currentRoot = d.data.id;
      loadAndRender();
      return;
    }
    currentRoot = d.data.id;
    loadAndRender();
  });

  // Right-click detail
  nodes.on('contextmenu', function(event, d) {
    event.preventDefault();
    showDetail(d.data.id);
  });

  updateSelectionVisuals();
}

// ── Detail panel ──
async function showDetail(personId) {
  const panel = document.getElementById('detail-panel');
  const content = document.getElementById('detail-content');
  content.innerHTML = '<p>Loading…</p>';
  panel.classList.add('open');

  try {
    const resp = await fetch(`/api/person/${personId}`);
    const data = await resp.json();

    let html = `<h2>${data.given_name || ''} ${data.surname || ''}</h2>`;
    html += `<p style="color:var(--fg2)">ID: ${data.id}</p>`;

    // Vital info
    html += '<div class="detail-section"><h4>Vital Information</h4>';
    if (data.birth_date || data.birth_place)
      html += `<p>Born: ${data.birth_date || '?'} ${data.birth_place ? '— ' + data.birth_place : ''}</p>`;
    if (data.death_date || data.death_place)
      html += `<p>Died: ${data.death_date || '?'} ${data.death_place ? '— ' + data.death_place : ''}</p>`;
    if (data.sex) html += `<p>Sex: ${data.sex === 'M' ? 'Male' : data.sex === 'F' ? 'Female' : data.sex}</p>`;
    if (data.confidence_tier) {
      const tierColors = { high: '#2d9a2d', medium: '#c9a100', low: '#d47a1a', speculative: '#c44' };
      const color = tierColors[data.confidence_tier] || '#999';
      html += `<p>Confidence: <span style="color:${color};font-weight:600">${data.confidence_tier}</span>`;
      if (data.confidence != null) html += ` (${data.confidence})`;
      if (data.source_count) html += ` &middot; ${data.source_count} source${data.source_count !== 1 ? 's' : ''}`;
      html += '</p>';
    }
    html += '</div>';

    // Parents
    if (data.parents && data.parents.length > 0) {
      html += '<div class="detail-section"><h4>Parents</h4><ul>';
      for (const p of data.parents) {
        html += `<li><a onclick="navigateTo(${p.id})">${p.given_name || ''} ${p.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Spouses
    if (data.spouses && data.spouses.length > 0) {
      html += '<div class="detail-section"><h4>Spouses</h4><ul>';
      for (const s of data.spouses) {
        html += `<li><a onclick="navigateTo(${s.id})">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Children
    if (data.children && data.children.length > 0) {
      html += '<div class="detail-section"><h4>Children</h4><ul>';
      for (const c of data.children) {
        html += `<li><a onclick="navigateTo(${c.id})">${c.given_name || ''} ${c.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Siblings
    if (data.siblings && data.siblings.length > 0) {
      html += '<div class="detail-section"><h4>Siblings</h4><ul>';
      for (const s of data.siblings) {
        html += `<li><a onclick="navigateTo(${s.id})">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    // Events
    if (data.events && data.events.length > 0) {
      html += '<div class="detail-section"><h4>Events</h4><ul>';
      for (const e of data.events) {
        html += `<li>${e.event_type}: ${e.event_date || '?'} ${e.event_place ? '— ' + e.event_place : ''}</li>`;
      }
      html += '</ul></div>';
    }

    // Re-root button + cross-links
    html += `<div class="detail-section">
      <button onclick="navigateTo(${data.id})" style="width:100%;margin-bottom:0.5rem">View tree from this person</button>
      <div style="display:flex;gap:0.4rem;flex-wrap:wrap">
        <a href="/ancestry.html?root=${data.id}" target="_blank" style="flex:1;text-align:center;display:block;padding:0.3rem 0.5rem;border:1px solid var(--border);border-radius:4px;font-size:0.75rem;text-decoration:none;color:var(--fg2);transition:all 0.15s" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--fg2)'">Ancestry</a>
        <a href="/graph.html" target="_blank" style="flex:1;text-align:center;display:block;padding:0.3rem 0.5rem;border:1px solid var(--border);border-radius:4px;font-size:0.75rem;text-decoration:none;color:var(--fg2);transition:all 0.15s" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--fg2)'">Graph</a>
        <a href="/related.html" target="_blank" style="flex:1;text-align:center;display:block;padding:0.3rem 0.5rem;border:1px solid var(--border);border-radius:4px;font-size:0.75rem;text-decoration:none;color:var(--fg2);transition:all 0.15s" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--fg2)'">Related?</a>
      </div>
    </div>`;

    content.innerHTML = html;
  } catch (err) {
    content.innerHTML = `<p style="color:#c44">Error loading details: ${err.message}</p>`;
  }
}

function navigateTo(id) {
  document.getElementById('detail-panel').classList.remove('open');
  currentRoot = id;
  loadAndRender();
}

// ── Person search ──
let searchTimeout = null;
const searchInput = document.getElementById('search-input');
const searchResults = document.getElementById('search-results');

searchInput.addEventListener('input', function() {
  clearTimeout(searchTimeout);
  const q = this.value.trim();
  if (q.length < 2) {
    searchResults.style.display = 'none';
    return;
  }
  searchTimeout = setTimeout(async () => {
    try {
      const resp = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
      const people = await resp.json();
      if (people.length === 0) {
        searchResults.innerHTML = '<div class="result"><span class="rmeta">No results</span></div>';
      } else {
        searchResults.innerHTML = people.slice(0, 15).map(p => {
          const name = `${p.given_name || ''} ${p.surname || ''}`.trim() || 'Unknown';
          const dates = [p.birth_date, p.death_date].filter(Boolean).join(' – ') || 'no dates';
          return `<div class="result" data-id="${p.id}">
            <div class="rname">${name}</div>
            <div class="rmeta">${dates}</div>
          </div>`;
        }).join('');
      }
      searchResults.style.display = 'block';
    } catch (err) {
      searchResults.style.display = 'none';
    }
  }, 250);
});

searchResults.addEventListener('click', function(event) {
  const result = event.target.closest('.result');
  if (result && result.dataset.id) {
    currentRoot = parseInt(result.dataset.id);
    searchInput.value = result.querySelector('.rname').textContent;
    searchResults.style.display = 'none';
    loadAndRender();
  }
});

// Hide search results on click outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.header-search')) {
    searchResults.style.display = 'none';
  }
});

// ── Options toggle ──
const optionsToggle = document.getElementById('options-toggle');
const controlsPanel = document.getElementById('controls-panel');
optionsToggle.addEventListener('click', () => {
  controlsPanel.classList.toggle('collapsed');
  optionsToggle.classList.toggle('open');
});

// ── Mode buttons ──
document.querySelectorAll('.mode-group button[data-mode]').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.mode-group button[data-mode]').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    currentMode = this.dataset.mode;
    loadAndRender();
  });
});

// ── Line style buttons ──
document.querySelectorAll('.mode-group button[data-line]').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.mode-group button[data-line]').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    currentLineStyle = this.dataset.line;
    // Re-render links without full reload
    const dir = currentMode === 'ancestors' ? -1 : 1;
    g.selectAll('.link').each(function() {
      const pathEl = d3.select(this);
      const linkDatum = pathEl.datum();
      if (linkDatum) {
        const linkDir = currentMode === 'both'
          ? (linkDatum.source.y <= 0 ? -1 : 1)
          : dir;
        pathEl.attr('d', linkPath(linkDatum, linkDir));
      }
    });
  });
});

// ── Depth slider ──
const depthRange = document.getElementById('depth-range');
depthRange.addEventListener('input', function() {
  document.getElementById('depth-val').textContent = this.value;
});
depthRange.addEventListener('change', function() {
  currentDepth = parseInt(this.value);
  loadAndRender();
});

// ── Toolbar buttons ──
document.getElementById('btn-fit').addEventListener('click', fitToView);
document.getElementById('btn-zoomin').addEventListener('click', () => {
  svg.transition().duration(300).call(zoom.scaleBy, 1.4);
});
document.getElementById('btn-zoomout').addEventListener('click', () => {
  svg.transition().duration(300).call(zoom.scaleBy, 0.7);
});
document.getElementById('btn-reset').addEventListener('click', () => {
  // Reset all state to defaults
  currentRoot = DEFAULT_ROOT;
  currentMode = 'ancestors';
  currentDepth = DEFAULT_DEPTH;
  currentLineStyle = 'curved';
  depthRange.value = DEFAULT_DEPTH;
  document.getElementById('depth-val').textContent = DEFAULT_DEPTH;
  document.querySelectorAll('.mode-group button[data-mode]').forEach(b => b.classList.remove('active'));
  document.querySelector('.mode-group button[data-mode="ancestors"]').classList.add('active');
  document.querySelectorAll('.mode-group button[data-line]').forEach(b => b.classList.remove('active'));
  document.querySelector('.mode-group button[data-line="curved"]').classList.add('active');
  searchInput.value = '';
  searchResults.style.display = 'none';
  document.getElementById('detail-panel').classList.remove('open');
  selectedNodes.clear();
  updateSelectionVisuals();
  loadAndRender().then(() => setTimeout(fitToView, 100));
});
document.getElementById('btn-collapse-all').addEventListener('click', () => {
  if (!treeData) return;
  collapseAllData(treeData);
  const dir = currentMode === 'ancestors' ? -1 : 1;
  rerender(dir);
});
document.getElementById('btn-expand-all').addEventListener('click', () => {
  if (!treeData) return;
  expandAllData(treeData);
  const dir = currentMode === 'ancestors' ? -1 : 1;
  rerender(dir);
});

// ── Fit to view ──
function fitToView() {
  const bounds = g.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;
  const svgEl = document.getElementById('tree-svg');
  const w = svgEl.clientWidth;
  const h = svgEl.clientHeight;
  const padding = 60;
  const scale = Math.min(
    (w - padding * 2) / bounds.width,
    (h - padding * 2) / bounds.height,
    1.5
  );
  const tx = w / 2 - (bounds.x + bounds.width / 2) * scale;
  const ty = h / 2 - (bounds.y + bounds.height / 2) * scale;
  svg.transition().duration(500)
    .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// ── Detail panel close ──
document.getElementById('detail-close').addEventListener('click', () => {
  document.getElementById('detail-panel').classList.remove('open');
});

// ── URL state ──
function updateURL() {
  const params = new URLSearchParams();
  if (currentRoot !== DEFAULT_ROOT) params.set('root', currentRoot);
  if (currentMode !== 'ancestors') params.set('mode', currentMode);
  if (currentDepth !== DEFAULT_DEPTH) params.set('depth', currentDepth);
  const qs = params.toString();
  const url = window.location.pathname + (qs ? '?' + qs : '');
  window.history.replaceState(null, '', url);
}

function readURL() {
  const params = new URLSearchParams(window.location.search);
  if (params.has('root')) currentRoot = parseInt(params.get('root'));
  if (params.has('mode')) {
    currentMode = params.get('mode');
    document.querySelectorAll('.mode-group button').forEach(b => {
      b.classList.toggle('active', b.dataset.mode === currentMode);
    });
  }
  if (params.has('depth')) {
    currentDepth = parseInt(params.get('depth'));
    depthRange.value = currentDepth;
    document.getElementById('depth-val').textContent = currentDepth;
  }
}

// ── Handle window resize ──
window.addEventListener('resize', () => {
  const headerH = document.querySelector('header').offsetHeight;
  document.getElementById('tree-svg').style.height = (window.innerHeight - headerH) + 'px';
});

// ── Init ──
readURL();
initSVG();
loadAndRender().then(() => {
  // Auto fit after initial render
  setTimeout(fitToView, 100);
});

// Handle popstate (back/forward)
window.addEventListener('popstate', () => {
  readURL();
  loadAndRender().then(() => setTimeout(fitToView, 100));
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // / to focus search
  if (e.key === '/' && !e.ctrlKey && !e.metaKey && document.activeElement !== searchInput) {
    e.preventDefault();
    searchInput.focus();
    searchInput.select();
  }
  // Escape to close panels and clear selection
  if (e.key === 'Escape') {
    document.getElementById('detail-panel').classList.remove('open');
    searchResults.style.display = 'none';
    searchInput.blur();
    if (selectedNodes.size > 0) {
      selectedNodes.clear();
      updateSelectionVisuals();
    }
  }
  // Home key to reset to George
  if (e.key === 'Home' && !e.ctrlKey && document.activeElement !== searchInput) {
    e.preventDefault();
    currentRoot = DEFAULT_ROOT;
    loadAndRender().then(() => setTimeout(fitToView, 100));
  }
});

// ── PNG Download ──
document.getElementById('btn-download-png').addEventListener('click', () => {
  const svgEl = document.getElementById('tree-svg');
  const bbox = g.node().getBBox();
  const pad = 40;

  // Clone SVG for export
  const clone = svgEl.cloneNode(true);
  clone.setAttribute('width', bbox.width + pad * 2);
  clone.setAttribute('height', bbox.height + pad * 2);
  clone.setAttribute('viewBox', `${bbox.x - pad} ${bbox.y - pad} ${bbox.width + pad * 2} ${bbox.height + pad * 2}`);
  // Ensure styles are inlined — add a white background rect
  const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  bgRect.setAttribute('x', bbox.x - pad);
  bgRect.setAttribute('y', bbox.y - pad);
  bgRect.setAttribute('width', bbox.width + pad * 2);
  bgRect.setAttribute('height', bbox.height + pad * 2);
  bgRect.setAttribute('fill', '#f8f6f1');
  clone.insertBefore(bgRect, clone.firstChild);

  // Serialize and draw to canvas
  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const img = new Image();
  img.onload = () => {
    const scale = 2; // hi-res
    const c = document.createElement('canvas');
    c.width = img.width * scale;
    c.height = img.height * scale;
    const ctx = c.getContext('2d');
    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0);
    URL.revokeObjectURL(url);
    const link = document.createElement('a');
    link.download = 'lack-lineage-tree.png';
    link.href = c.toDataURL('image/png');
    link.click();
  };
  img.src = url;
});
</script>
<script src="/data/help-widget.js"></script>
<script>
initHelp({
  title: 'Tree Explorer',
  intro: 'An interactive collapsible tree view. Browse ancestors, descendants, or both directions from any person. Drag nodes to rearrange, select multiple with marquee, and explore the family structure.',
  keyboard: [
    { key: '/', action: 'Focus the search bar' },
    { key: 'Escape', action: 'Close panels, clear selection' },
    { key: 'Home', action: 'Reset to George l Lack as root' },
    { key: '?', action: 'Toggle this help panel' }
  ],
  mouse: [
    { key: 'Left-click node', action: 'Expand or collapse that branch' },
    { key: 'Ctrl + Left-click node', action: 'Toggle node in/out of selection' },
    { key: 'Shift + Left-click node', action: 'Re-root the tree on that person' },
    { key: 'Right-click node', action: 'Open detail panel' },
    { key: 'Drag node', action: 'Move selected node(s) — lines follow' },
    { key: 'Drag background', action: 'Draw selection rectangle (marquee)' },
    { key: 'Ctrl + Release marquee', action: 'Add marquee nodes to existing selection' },
    { key: 'Hover node', action: 'Show tooltip with name, dates, spouse' },
    { key: 'Middle-click drag', action: 'Pan the canvas' },
    { key: 'Scroll wheel', action: 'Zoom in/out' }
  ],
  sections: [
    { title: 'Modes', icon: '🔀', html: `
      <p>Three modes control what the tree shows:</p>
      <ul>
        <li><strong>Ancestors</strong> — Shows parents, grandparents, etc. fanning to the right</li>
        <li><strong>Descendants</strong> — Shows children, grandchildren, etc. fanning to the right</li>
        <li><strong>Both</strong> — Ancestors go left, descendants go right from the root</li>
      </ul>
      <p>Switch modes using the buttons in the Options panel.</p>
    ` },
    { title: 'Selection & Dragging', icon: '✋', html: `
      <p><strong>Ctrl+click</strong> a node to select it (highlighted). Ctrl+click again to deselect. <strong>Drag</strong> any selected node to reposition all selected nodes — connection lines update in real time.</p>
      <p>To select multiple nodes at once, <strong>left-click and drag</strong> on empty space to draw a selection rectangle. Any node whose center falls inside gets selected.</p>
      <p>Hold <strong>Ctrl</strong> when releasing the rectangle to add to an existing selection instead of replacing it.</p>
      <p>Press <strong>Escape</strong> or click empty space to deselect all.</p>
    ` },
    { title: 'Expanding & Collapsing', icon: '🌳', html: `
      <p><strong>Click</strong> any node to toggle its children visible/hidden. A <code>+N</code> badge shows how many hidden children exist.</p>
      <p>Use <strong>Collapse All</strong> to close every branch, or <strong>Expand All</strong> to open them. Branches beyond depth 4 auto-collapse on first load for performance.</p>
    ` },
    { title: 'Line Styles', icon: '〰️', html: `
      <p>In the Options panel, choose between three line styles:</p>
      <ul>
        <li><strong>Curved</strong> — Smooth bezier curves (default)</li>
        <li><strong>Straight</strong> — Direct diagonal lines</li>
        <li><strong>Step</strong> — Right-angle step connectors</li>
      </ul>
      <p>Line style changes apply instantly without reloading the tree.</p>
    ` },
    { title: 'Depth Slider', icon: '📏', html: `
      <p>The depth slider (1–14) controls how many generations to load. Increasing depth fetches more data and may take a moment for large trees.</p>
      <p>The default depth is 6 generations.</p>
    ` },
    { title: 'Detail Panel', icon: '📋', html: `
      <p><strong>Right-click</strong> any node to open the detail panel on the right side. It shows:</p>
      <ul>
        <li>Vital dates and birthplace</li>
        <li>Parents, spouses, children, and siblings</li>
        <li>Life events from the database</li>
        <li>Cross-links to Ancestry, Graph, and Related pages</li>
      </ul>
      <p>Press <strong>Escape</strong> or click the × to close the panel.</p>
    ` },
    { title: 'Re-rooting', icon: '🎯', html: `
      <p>Hold <strong>Shift</strong> and click any node to make that person the new root. The URL updates to <code>?root=ID</code> so you can bookmark or share any view.</p>
      <p>Press <strong>Home</strong> to return to George l Lack.</p>
    ` },
    { title: 'Node Colors', icon: '🎨', html: `
      <ul>
        <li><strong>Blue border</strong> — Male</li>
        <li><strong>Red border</strong> — Female</li>
        <li><strong>Gray border</strong> — Unknown sex</li>
        <li><strong>Confidence dot</strong> — Green (high), Yellow (medium), Orange (low), Red (speculative)</li>
      </ul>
    ` },
    { title: 'Search', icon: '🔍', html: `
      <p>Press <strong>/</strong> or click the search bar in the header to find anyone by name. Select a result to navigate to them as the new tree root.</p>
    ` }
  ]
});
</script>
</body>
</html>

