<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lack Lineage — Graph</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f8f6f1;
  --bg2: #fff;
  --fg: #2a2520;
  --fg2: #6b6360;
  --accent: #8b6914;
  --accent2: #a07d2a;
  --red: #b85450;
  --border: #d8d2c8;
  --radius: 6px;
  --shadow: 0 2px 8px rgba(0,0,0,0.12);
  --font: 'Georgia', 'Times New Roman', serif;
  --mono: 'Consolas', 'Monaco', monospace;
}
html, body { height: 100%; overflow: hidden; }
body { font-family: var(--font); color: var(--fg); background: var(--bg); }

/* ── Header ── */
header {
  background: var(--fg);
  color: var(--bg);
  padding: 0.75rem 2rem;
  display: flex;
  align-items: center;
  gap: 2rem;
  z-index: 100;
  position: relative;
}
header h1 { font-size: 1.1rem; font-weight: 600; letter-spacing: 0.5px; }
header h1 a { color: var(--bg); text-decoration: none; }
header h1 span { color: var(--accent2); }
header nav { display: flex; gap: 1.5rem; }
header nav a {
  color: rgba(248,246,241,0.6);
  text-decoration: none;
  font-size: 0.85rem;
  letter-spacing: 0.3px;
  transition: color 0.2s;
}
header nav a:hover, header nav a.active { color: var(--bg); }

/* ── Controls panel ── */
.controls {
  position: absolute;
  top: 70px;
  left: 16px;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  z-index: 50;
  width: 260px;
  box-shadow: var(--shadow);
  font-size: 0.82rem;
}
.controls h3 {
  font-size: 0.95rem;
  margin-bottom: 12px;
  color: var(--fg);
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.controls h3 button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.75rem;
  color: var(--fg2);
  padding: 2px 6px;
  border-radius: 3px;
}
.controls h3 button:hover { background: var(--border); }
.ctrl-row { margin-bottom: 10px; }
.ctrl-row label {
  display: block;
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--fg2);
  margin-bottom: 4px;
}
.ctrl-row select, .ctrl-row input[type="text"] {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-family: var(--font);
  font-size: 0.82rem;
  background: var(--bg);
  color: var(--fg);
}
.ctrl-row select:focus, .ctrl-row input:focus {
  outline: none;
  border-color: var(--accent);
}
.ctrl-row .range-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.ctrl-row input[type="range"] {
  flex: 1;
  accent-color: var(--accent);
  height: 4px;
}
.ctrl-row .range-val {
  font-size: 0.72rem;
  color: var(--fg2);
  min-width: 18px;
  text-align: right;
}

/* Search autocomplete */
.search-wrap { position: relative; }
.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  max-height: 200px;
  overflow-y: auto;
  background: var(--bg2);
  border: 1px solid var(--border);
  border-top: none;
  border-radius: 0 0 var(--radius) var(--radius);
  box-shadow: var(--shadow);
  display: none;
  z-index: 999;
}
.search-results .sr-item {
  padding: 6px 10px;
  cursor: pointer;
  font-size: 0.8rem;
  border-bottom: 1px solid var(--border);
}
.search-results .sr-item:last-child { border-bottom: none; }
.search-results .sr-item:hover, .search-results .sr-item.active {
  background: var(--accent);
  color: var(--bg);
}
.search-results .sr-item .sr-dates {
  font-size: 0.7rem;
  opacity: 0.7;
  margin-left: 6px;
}

/* Stats */
.stats {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
  font-size: 0.75rem;
  color: var(--fg2);
  line-height: 1.6;
}
.stats strong { color: var(--fg); }

/* Focus info bar */
.focus-bar {
  position: absolute;
  top: 70px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--fg);
  color: var(--bg);
  padding: 8px 20px;
  border-radius: 20px;
  font-size: 0.85rem;
  z-index: 50;
  display: none;
  align-items: center;
  gap: 12px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.2);
  white-space: nowrap;
}
.focus-bar .focus-name { font-weight: 600; }
.focus-bar .focus-dates { opacity: 0.7; font-size: 0.78rem; }
.focus-bar button {
  background: rgba(255,255,255,0.15);
  border: none;
  color: var(--bg);
  padding: 4px 12px;
  border-radius: 12px;
  cursor: pointer;
  font-family: var(--font);
  font-size: 0.78rem;
}
.focus-bar button:hover { background: rgba(255,255,255,0.25); }

/* Legend */
.legend {
  position: absolute;
  bottom: 16px;
  left: 16px;
  background: rgba(255,255,255,0.92);
  backdrop-filter: blur(4px);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px 14px;
  font-size: 0.72rem;
  z-index: 50;
  display: flex;
  gap: 14px;
  align-items: center;
  color: var(--fg2);
}
.legend-item { display: flex; align-items: center; gap: 5px; }
.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}
.legend-line {
  width: 20px;
  height: 0;
  border-top: 2px solid;
  flex-shrink: 0;
}
.legend-line.dashed { border-top-style: dashed; }

/* Tooltip */
.tooltip {
  position: fixed;
  background: var(--fg);
  color: var(--bg);
  padding: 10px 14px;
  border-radius: var(--radius);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s;
  z-index: 200;
  max-width: 280px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
  font-size: 0.8rem;
  line-height: 1.5;
}
.tooltip .t-name { font-weight: 600; font-size: 0.9rem; margin-bottom: 2px; }
.tooltip .t-dates { opacity: 0.75; font-size: 0.78rem; }
.tooltip .t-place { opacity: 0.6; font-size: 0.72rem; margin-top: 2px; }
.tooltip .t-rels { margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.15); font-size: 0.72rem; opacity: 0.8; }
.tooltip .t-conf { margin-top: 4px; font-size: 0.68rem; opacity: 0.5; }

/* Path result bar */
.path-bar {
  position: absolute;
  bottom: 50px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--fg);
  color: var(--bg);
  padding: 10px 20px;
  border-radius: var(--radius);
  font-size: 0.82rem;
  z-index: 50;
  display: none;
  align-items: center;
  gap: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
  max-width: 90vw;
  overflow-x: auto;
  white-space: nowrap;
}
.path-bar .path-step { display: inline-flex; align-items: center; gap: 6px; }
.path-bar .path-person {
  background: rgba(255,255,255,0.15);
  padding: 3px 8px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.78rem;
}
.path-bar .path-person:hover { background: rgba(255,255,255,0.3); }
.path-bar .path-rel {
  font-size: 0.68rem;
  opacity: 0.6;
  font-style: italic;
}
.path-bar .path-close {
  background: rgba(255,255,255,0.15);
  border: none;
  color: var(--bg);
  padding: 2px 8px;
  border-radius: 8px;
  cursor: pointer;
  margin-left: 8px;
  font-size: 0.75rem;
}
.path-bar .path-close:hover { background: rgba(255,255,255,0.3); }

/* Minimap */
.minimap {
  position: absolute;
  bottom: 16px;
  right: 16px;
  width: 160px;
  height: 120px;
  background: rgba(255,255,255,0.9);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  z-index: 50;
  overflow: hidden;
  cursor: pointer;
}
.minimap canvas {
  width: 100%;
  height: 100%;
}

/* Help hint */
.help-hint {
  position: absolute;
  bottom: 142px;
  right: 16px;
  font-size: 0.68rem;
  color: var(--fg2);
  opacity: 0.5;
  z-index: 50;
  text-align: right;
  line-height: 1.5;
}

canvas#canvas { display: block; cursor: grab; }
canvas#canvas:active { cursor: grabbing; }

@media (max-width: 700px) {
  header { padding: 0.5rem 1rem; gap: 1rem; }
  header nav { gap: 0.8rem; }
  .controls { width: 220px; left: 8px; top: 60px; padding: 12px; }
  .legend { bottom: 8px; left: 8px; gap: 8px; font-size: 0.65rem; }
}
</style>
</head>
<body>

<header>
  <h1><a href="/">Lack <span>Lineage</span></a></h1>
  <nav>
    <a href="/">Dashboard</a>
    <a href="/search.html">Search</a>
    <a href="/research.html">Research</a>
    <a href="/graph.html" class="active">Graph</a>
    <a href="/tree.html">Tree</a>
  </nav>
</header>

<div class="controls" id="controls">
  <h3>
    Family Graph
    <button id="resetBtn" title="Reset view">Reset</button>
    <button id="recenterBtn" title="Fit all nodes on screen">Recenter</button>
    <button id="autoCenterBtn" title="Keep graph fitted to screen" style="opacity:0.5">Auto</button>
  </h3>

  <div class="ctrl-row search-wrap">
    <label>Find Person</label>
    <input type="text" id="searchInput" placeholder="Type a name..." autocomplete="off">
    <div class="search-results" id="searchResults"></div>
  </div>

  <div class="ctrl-row">
    <label>View</label>
    <select id="viewMode">
      <option value="connected" selected>Family Network</option>
      <option value="ryan">Ryan's Family</option>
    </select>
  </div>

  <div class="ctrl-row">
    <label>Color by</label>
    <select id="colorMode">
      <option value="sex" selected>Sex</option>
      <option value="surname">Surname</option>
      <option value="generation">Generation from Ryan</option>
      <option value="confidence">Confidence</option>
      <option value="century">Birth Century</option>
      <option value="region">Country / Region</option>
      <option value="status">Living / Dead</option>
    </select>
  </div>

  <div class="ctrl-row">
    <label>Node Size</label>
    <div class="range-row">
      <input type="range" id="sizeSlider" min="0.3" max="3" step="0.1" value="1">
      <span class="range-val" id="sizeVal">1.0</span>
    </div>
  </div>

  <div class="ctrl-row">
    <label>Link Distance</label>
    <div class="range-row">
      <input type="range" id="distSlider" min="10" max="150" step="5" value="55">
      <span class="range-val" id="distVal">55</span>
    </div>
  </div>

  <div class="ctrl-row">
    <label>Repulsion</label>
    <div class="range-row">
      <input type="range" id="chargeSlider" min="5" max="250" step="5" value="80">
      <span class="range-val" id="chargeVal">80</span>
    </div>
  </div>

  <div class="ctrl-row">
    <label>Gravity</label>
    <div class="range-row">
      <input type="range" id="gravSlider" min="1" max="20" step="1" value="3">
      <span class="range-val" id="gravVal">3</span>
    </div>
  </div>

  <div class="ctrl-row">
    <label>Collision Pad</label>
    <div class="range-row">
      <input type="range" id="collSlider" min="0" max="12" step="1" value="1">
      <span class="range-val" id="collVal">1</span>
    </div>
  </div>

  <div class="stats" id="stats"></div>
</div>

<div class="focus-bar" id="focusBar">
  <span class="focus-name" id="focusName"></span>
  <span class="focus-dates" id="focusDates"></span>
  <button id="focusClear">Show All</button>
</div>

<div class="legend" id="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#4a7fb5"></div> Male</div>
  <div class="legend-item"><div class="legend-dot" style="background:#c45a8d"></div> Female</div>
  <div class="legend-item"><div class="legend-dot" style="background:#aaa"></div> Unknown</div>
  <div class="legend-item"><div class="legend-line" style="border-color:var(--accent);opacity:0.5"></div> Parent</div>
  <div class="legend-item"><div class="legend-line dashed" style="border-color:var(--red);opacity:0.5"></div> Spouse</div>
</div>

<div class="path-bar" id="pathBar"></div>

<div class="minimap" id="minimap"><canvas id="minimapCanvas"></canvas></div>

<div class="help-hint">Click to focus &middot; Double-click to navigate<br>Right-click two people: "How related?"</div>

<div class="tooltip" id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
// ── State ──
let allNodes = [], allLinks = [];
let nodes = [], links = [];
let simulation = null;
let transform = d3.zoomIdentity;
let hoveredNode = null, draggedNode = null, focusedNode = null;
let degreeMap = new Map();
let neighborMap = new Map();
let sizeMult = 1.0;
let userLinkDist = null;   // null = auto from node count
let userCharge = null;
let userGravity = null;
let userCollPad = 1;
let generationMap = new Map(); // generation distance from Ryan
let highlightedPath = null;     // array of node IDs for path display
let pathStartNode = null;       // first node for right-click path finding
let autoCenter = false;         // continuously fit-to-view on each tick

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const focusBar = document.getElementById('focusBar');
let width = window.innerWidth, height = window.innerHeight;

// ── Colors ──
const sexColors = { M: '#4a7fb5', F: '#c45a8d', U: '#999999' };
let surnameColorScale = d3.scaleOrdinal(d3.schemeTableau10);

const confColors = {
  high: '#4a8c5c',
  medium: '#c49a2a',
  low: '#b85450',
  speculative: '#8855aa'
};

const statusColors = { living: '#4a8c5c', dead: '#8b7355' };

// Century color palette
const centuryColors = {
  '1400s': '#7b4f8a',
  '1500s': '#6a5acd',
  '1600s': '#3a7ca5',
  '1700s': '#2e8b57',
  '1800s': '#c49a2a',
  '1900s': '#c45a3c',
  '2000s': '#e63946'
};

// Country/Region color palette
const regionColors = {
  'USA': '#4a7fb5',
  'Pennsylvania': '#4a7fb5',
  'PA': '#4a7fb5',
  'United States': '#4a7fb5',
  'United States of America': '#4a7fb5',
  'Michigan': '#5a99cc',
  'Canada': '#c45a3c',
  'Germany': '#c49a2a',
  'Deutschland': '#c49a2a',
  'Ireland': '#4a8c5c',
  'England': '#8b6914',
  'Scotland': '#3a5a8c',
  'Wales': '#7b4f8a',
  'France': '#6a5acd',
  'Switzerland': '#b85450',
  'Italy': '#2e8b57',
  'Hungary': '#8b4513',
  'Czechoslovakia': '#5a7a5a',
  'Belgium': '#c4783c'
};
const regionFallback = '#aaaaaa';
let regionColorScale = d3.scaleOrdinal(d3.schemeSet3);

// Generation from Ryan color scale
const genScale = d3.scaleSequential(d3.interpolateViridis).domain([0, 10]);

function getCountry(d) {
  const bp = d.birth_place;
  if (!bp) return null;
  const parts = bp.split(',').map(s => s.trim()).filter(Boolean);
  return parts.length ? parts[parts.length - 1] : null;
}

function getCentury(d) {
  if (!d.birth_year) return null;
  const c = Math.floor(d.birth_year / 100) * 100;
  return c + 's';
}

function getColor(d) {
  const mode = document.getElementById('colorMode').value;
  if (mode === 'surname') {
    return d.surname ? surnameColorScale(d.surname) : '#cccccc';
  }
  if (mode === 'confidence') {
    return confColors[d.confidence_tier] || '#999999';
  }
  if (mode === 'generation') {
    const gen = generationMap.get(d.id);
    if (gen === undefined) return '#dddddd';
    return genScale(Math.min(gen, 10));
  }
  if (mode === 'century') {
    const c = getCentury(d);
    if (!c) return '#dddddd';
    return centuryColors[c] || '#777777';
  }
  if (mode === 'region') {
    const r = getCountry(d);
    if (!r) return '#dddddd';
    return regionColors[r] || regionColorScale(r);
  }
  if (mode === 'status') {
    return d.death_date ? statusColors.dead : statusColors.living;
  }
  return sexColors[d.sex] || sexColors.U;
}

// ── Compute generation distances from Ryan ──
function computeGenerations() {
  generationMap = new Map();
  const ryan = allNodes.find(n => n.id === 58) || allNodes.find(n => /ryan.*lack/i.test(n.name));
  if (!ryan) return;
  generationMap.set(ryan.id, 0);
  let frontier = [ryan.id];
  while (frontier.length) {
    const next = [];
    for (const nid of frontier) {
      const gen = generationMap.get(nid);
      for (const l of allLinks) {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        let neighbor = null;
        if (sid === nid) neighbor = tid;
        else if (tid === nid) neighbor = sid;
        if (neighbor !== null && !generationMap.has(neighbor)) {
          generationMap.set(neighbor, gen + 1);
          next.push(neighbor);
        }
      }
    }
    frontier = next;
  }
}

// ── Path finding (BFS shortest path through all links) ──
function findPathBFS(fromId, toId) {
  if (fromId === toId) return [fromId];
  const prev = new Map();
  prev.set(fromId, null);
  let frontier = [fromId];
  while (frontier.length) {
    const next = [];
    for (const nid of frontier) {
      for (const l of allLinks) {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        let neighbor = null;
        if (sid === nid) neighbor = tid;
        else if (tid === nid) neighbor = sid;
        if (neighbor !== null && !prev.has(neighbor)) {
          prev.set(neighbor, nid);
          if (neighbor === toId) {
            const path = [];
            let cur = toId;
            while (cur !== null) { path.unshift(cur); cur = prev.get(cur); }
            return path;
          }
          next.push(neighbor);
        }
      }
    }
    frontier = next;
  }
  return null;
}

function showPath(path) {
  highlightedPath = path;
  const bar = document.getElementById('pathBar');
  let html = '<span style="font-size:0.72rem;opacity:0.7;margin-right:6px">' + path.length + ' steps:</span>';
  for (let i = 0; i < path.length; i++) {
    const nd = allNodes.find(n => n.id === path[i]);
    if (!nd) continue;
    html += `<span class="path-person" data-id="${nd.id}">${nd.name}</span>`;
    if (i < path.length - 1) {
      let rel = '→';
      for (const l of allLinks) {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        if ((sid === path[i] && tid === path[i+1]) || (tid === path[i] && sid === path[i+1])) {
          if (l.type === 'spouse') rel = '♥';
          else if (sid === path[i]) rel = '↓';
          else rel = '↑';
          break;
        }
      }
      html += `<span class="path-rel">${rel}</span>`;
    }
  }
  html += `<button class="path-close" onclick="clearPath()">✕</button>`;
  bar.innerHTML = html;
  bar.style.display = 'flex';
  bar.querySelectorAll('.path-person').forEach(el => {
    el.addEventListener('click', () => {
      const nd = allNodes.find(n => n.id === parseInt(el.dataset.id));
      if (nd) focusOnNode(nd);
    });
  });
  draw();
}

function clearPath() {
  highlightedPath = null;
  document.getElementById('pathBar').style.display = 'none';
  draw();
}

// ── Degree & neighbor helpers ──
function buildMaps(nodeList, linkList) {
  degreeMap = new Map();
  neighborMap = new Map();
  for (const n of nodeList) {
    degreeMap.set(n.id, 0);
    neighborMap.set(n.id, new Set());
  }
  for (const l of linkList) {
    const sid = typeof l.source === 'object' ? l.source.id : l.source;
    const tid = typeof l.target === 'object' ? l.target.id : l.target;
    degreeMap.set(sid, (degreeMap.get(sid) || 0) + 1);
    degreeMap.set(tid, (degreeMap.get(tid) || 0) + 1);
    if (neighborMap.has(sid)) neighborMap.get(sid).add(tid);
    if (neighborMap.has(tid)) neighborMap.get(tid).add(sid);
  }
}

function nodeRadius(d) {
  const deg = degreeMap.get(d.id) || 0;
  const base = Math.max(3, Math.min(12, 3 + deg * 1.2));
  return base * sizeMult;
}

function nodeOpacity(d) {
  if (d.confidence_tier === 'low') return 0.55;
  if (d.confidence_tier === 'medium') return 0.8;
  return 1;
}

// ── Get N-hop neighborhood ──
function getNeighborhood(nodeId, hops) {
  const visited = new Set([nodeId]);
  let frontier = [nodeId];
  for (let i = 0; i < hops; i++) {
    const next = [];
    for (const nid of frontier) {
      const nb = neighborMap.get(nid);
      if (nb) for (const id of nb) {
        if (!visited.has(id)) { visited.add(id); next.push(id); }
      }
    }
    frontier = next;
  }
  return visited;
}

// ── Search ──
const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
let searchTimeout = null;

searchInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const q = searchInput.value.trim().toLowerCase();
  if (q.length < 2) { searchResults.style.display = 'none'; return; }

  searchTimeout = setTimeout(() => {
    const matches = allNodes
      .filter(n => n.name.toLowerCase().includes(q))
      .sort((a, b) => (degreeMap.get(b.id) || 0) - (degreeMap.get(a.id) || 0))
      .slice(0, 12);

    if (!matches.length) { searchResults.style.display = 'none'; return; }

    searchResults.innerHTML = matches.map(n => {
      const d = [];
      if (n.birth_year) d.push('b.' + n.birth_year);
      if (n.death_date) { const m = n.death_date.match(/(\d{4})/); if (m) d.push('d.' + m[1]); }
      return `<div class="sr-item" data-id="${n.id}">${n.name}${d.length ? `<span class="sr-dates">${d.join(' — ')}</span>` : ''}</div>`;
    }).join('');
    searchResults.style.display = 'block';
  }, 150);
});

searchResults.addEventListener('click', (e) => {
  const item = e.target.closest('.sr-item');
  if (!item) return;
  const node = allNodes.find(n => n.id === parseInt(item.dataset.id));
  if (node) focusOnNode(node);
  searchInput.value = '';
  searchResults.style.display = 'none';
});

searchInput.addEventListener('blur', () => {
  setTimeout(() => searchResults.style.display = 'none', 200);
});

searchInput.addEventListener('keydown', (e) => {
  const items = searchResults.querySelectorAll('.sr-item');
  const active = searchResults.querySelector('.sr-item.active');
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (!active && items.length) items[0].classList.add('active');
    else if (active && active.nextElementSibling) { active.classList.remove('active'); active.nextElementSibling.classList.add('active'); }
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (active && active.previousElementSibling) { active.classList.remove('active'); active.previousElementSibling.classList.add('active'); }
  } else if (e.key === 'Enter') {
    const sel = searchResults.querySelector('.sr-item.active') || searchResults.querySelector('.sr-item');
    if (sel) sel.click();
  } else if (e.key === 'Escape') {
    searchResults.style.display = 'none';
    searchInput.blur();
  }
});

// ── Focus on a node (2-hop neighborhood) ──
function focusOnNode(target) {
  // We need to rebuild maps from allNodes/allLinks first for accurate neighborhoods
  buildMaps(allNodes, allLinks);

  focusedNode = target;
  const hood = getNeighborhood(target.id, 2);

  nodes = allNodes.filter(n => hood.has(n.id)).map(n => ({
    ...n,
    x: width / 2 + (Math.random() - 0.5) * 300,
    y: height / 2 + (Math.random() - 0.5) * 300
  }));
  const nodeIds = new Set(nodes.map(n => n.id));
  links = allLinks.filter(l => nodeIds.has(l.source) && nodeIds.has(l.target)).map(l => ({...l}));

  buildMaps(nodes, links);
  updateStats();
  showFocusBar(target);
  initSimulation();

  // Zoom to the focused node after layout settles
  setTimeout(() => {
    const tn = nodes.find(n => n.id === target.id);
    if (tn) zoomToNode(tn);
  }, 900);
}

function clearFocus() {
  focusedNode = null;
  focusBar.style.display = 'none';
  applyView();
}

function showFocusBar(node) {
  const d = [];
  if (node.birth_year) d.push('b. ' + node.birth_year);
  if (node.death_date) { const m = node.death_date.match(/(\d{4})/); if (m) d.push('d. ' + m[1]); }
  document.getElementById('focusName').textContent = node.name;
  document.getElementById('focusDates').textContent = d.join(' — ');
  focusBar.style.display = 'flex';
}

function zoomToNode(node) {
  const k = 2;
  const tx = width / 2 - node.x * k;
  const ty = height / 2 - node.y * k;
  d3.select(canvas).transition().duration(1200).ease(d3.easeCubicInOut)
    .call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
}

// ── Load data ──
async function loadGraph() {
  const viewMode = document.getElementById('viewMode').value;
  const url = viewMode === 'ryan' ? '/data/graph-ryan.json' : '/data/graph.json';

  const res = await fetch(url);
  const data = await res.json();

  allNodes = data.nodes;
  allLinks = data.links;

  // Compute generation distances from Ryan
  computeGenerations();

  // Build surname scale from full data
  const surnames = [...new Set(allNodes.map(n => n.surname).filter(Boolean))];
  surnames.sort((a, b) => {
    const ac = allNodes.filter(n => n.surname === a).length;
    const bc = allNodes.filter(n => n.surname === b).length;
    return bc - ac;
  });
  surnameColorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(surnames);

  applyView();
}

function applyView() {
  focusedNode = null;
  focusBar.style.display = 'none';

  nodes = allNodes.map(n => ({
    ...n,
    x: width / 2 + (Math.random() - 0.5) * 400,
    y: height / 2 + (Math.random() - 0.5) * 400
  }));

  const nodeIds = new Set(nodes.map(n => n.id));
  links = allLinks.filter(l => nodeIds.has(l.source) && nodeIds.has(l.target)).map(l => ({...l}));

  buildMaps(nodes, links);
  updateStats();
  initSimulation();

  // Reset zoom
  transform = d3.zoomIdentity;
  d3.select(canvas).call(zoomBehavior.transform, d3.zoomIdentity);
}

function updateStats() {
  const pc = links.filter(l => l.type === 'parent_child').length;
  const sp = links.filter(l => l.type === 'spouse').length;
  document.getElementById('stats').innerHTML =
    `<strong>${nodes.length}</strong> people &middot; <strong>${pc}</strong> parent-child &middot; <strong>${sp}</strong> spouse` +
    (focusedNode ? '<br><em>Showing 2-hop neighborhood</em>' : '');
}

// ── Simulation ──
function initSimulation() {
  if (simulation) simulation.stop();

  const n = nodes.length;
  const autoCharge = n > 500 ? -12 : n > 100 ? -35 : -80;
  const autoDist = n > 500 ? 20 : n > 100 ? 40 : 55;
  const autoGrav = 0.03;

  const linkDist = userLinkDist != null ? userLinkDist : autoDist;
  const chargeStr = userCharge != null ? -userCharge : autoCharge;
  const grav = userGravity != null ? userGravity / 100 : autoGrav;
  const collPad = userCollPad;

  // Sync slider displays to current values
  document.getElementById('distSlider').value = linkDist;
  document.getElementById('distVal').textContent = linkDist;
  document.getElementById('chargeSlider').value = Math.abs(chargeStr);
  document.getElementById('chargeVal').textContent = Math.abs(chargeStr);
  document.getElementById('gravSlider').value = Math.round(grav * 100);
  document.getElementById('gravVal').textContent = Math.round(grav * 100);
  document.getElementById('collSlider').value = collPad;
  document.getElementById('collVal').textContent = collPad;

  simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links)
      .id(d => d.id)
      .distance(d => d.type === 'spouse' ? linkDist * 0.5 : linkDist)
      .strength(d => d.type === 'spouse' ? 0.7 : 0.3))
    .force('charge', d3.forceManyBody().strength(chargeStr))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide(d => nodeRadius(d) + collPad))
    .force('x', d3.forceX(width / 2).strength(grav))
    .force('y', d3.forceY(height / 2).strength(grav))
    .alphaDecay(0.015)
    .on('tick', () => {
      if (autoCenter) fitAllNodes();
      draw(); drawMinimap();
    });
}

// ── Drawing ──
function draw() {
  ctx.save();
  ctx.clearRect(0, 0, width, height);
  ctx.translate(transform.x, transform.y);
  ctx.scale(transform.k, transform.k);

  // Links
  for (const l of links) {
    if (typeof l.source.x === 'undefined') continue;
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    if (l.type === 'spouse') {
      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(184, 84, 80, 0.25)';
      ctx.lineWidth = 0.7;
    } else {
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(139, 105, 20, 0.12)';
      ctx.lineWidth = 0.7;
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Arrowhead on parent → child links
    if (l.type !== 'spouse') {
      const dx = l.target.x - l.source.x;
      const dy = l.target.y - l.source.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 10) {
        const ux = dx / len, uy = dy / len;
        const tr = nodeRadius(l.target);
        const ax = l.target.x - ux * (tr + 2);
        const ay = l.target.y - uy * (tr + 2);
        const sz = Math.max(3, 4 / Math.max(transform.k, 0.5));
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax - ux * sz - uy * sz * 0.4, ay - uy * sz + ux * sz * 0.4);
        ctx.lineTo(ax - ux * sz + uy * sz * 0.4, ay - uy * sz - ux * sz * 0.4);
        ctx.closePath();
        ctx.fillStyle = 'rgba(139, 105, 20, 0.3)';
        ctx.fill();
      }
    }
  }

  // Highlighted path overlay
  if (highlightedPath && highlightedPath.length > 1) {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#e63946';
    ctx.setLineDash([]);
    for (let i = 0; i < highlightedPath.length - 1; i++) {
      const from = nodes.find(n => n.id === highlightedPath[i]);
      const to = nodes.find(n => n.id === highlightedPath[i + 1]);
      if (from && to) {
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }
    }
  }

  // Highlight hovered connections
  if (hoveredNode) {
    for (const l of links) {
      const sid = l.source.id ?? l.source;
      const tid = l.target.id ?? l.target;
      if (sid === hoveredNode.id || tid === hoveredNode.id) {
        ctx.beginPath();
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.strokeStyle = l.type === 'spouse' ? 'rgba(184,84,80,0.85)' : 'rgba(139,105,20,0.7)';
        ctx.lineWidth = 2;
        if (l.type === 'spouse') ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // Nodes
  const hoverNb = hoveredNode ? (neighborMap.get(hoveredNode.id) || new Set()) : null;

  for (const d of nodes) {
    const r = nodeRadius(d);
    const isHov = hoveredNode && hoveredNode.id === d.id;
    const isFoc = focusedNode && focusedNode.id === d.id;
    const drawR = isHov ? r + 2 : r;
    const color = getColor(d);

    let alpha = nodeOpacity(d);
    if (hoveredNode && !isHov) {
      alpha = hoverNb.has(d.id) ? alpha : alpha * 0.12;
    }

    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(d.x, d.y, drawR, 0, Math.PI * 2);

    ctx.fillStyle = color;
    ctx.fill();

    // Living indicator: subtle green outer ring
    if (!d.death_date) {
      ctx.save();
      ctx.globalAlpha = alpha * 0.5;
      ctx.beginPath();
      ctx.arc(d.x, d.y, drawR + 1.5, 0, Math.PI * 2);
      ctx.strokeStyle = '#4a8c5c';
      ctx.lineWidth = 1.2;
      ctx.stroke();
      ctx.restore();
      ctx.globalAlpha = alpha;
    }

    // Path highlight ring
    if (highlightedPath && highlightedPath.includes(d.id)) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(d.x, d.y, drawR + 3, 0, Math.PI * 2);
      ctx.strokeStyle = '#e63946';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      ctx.stroke();
      ctx.restore();
      ctx.globalAlpha = alpha;
    }

    ctx.strokeStyle = isHov ? 'rgba(0,0,0,0.4)' : (isFoc ? 'rgba(139,105,20,0.6)' : 'rgba(0,0,0,0.08)');
    ctx.lineWidth = isHov ? 1.5 : (isFoc ? 1.2 : 0.5);
    ctx.stroke();

    // ── Smart labels: progressively reveal info by zoom level ──
    const k = transform.k;
    const effR = drawR * k; // effective screen-space radius
    const isSpecial = isHov || isFoc;

    // Tier 1: Name label (zoom > 1.2, or node big enough on screen, or hovered/focused)
    const showName = isSpecial || k > 1.2 || effR > 8;
    // Tier 2: Dates (zoom > 2.5 or hovered/focused)
    const showDates = isSpecial || k > 2.5;
    // Tier 3: Place (zoom > 4 or hovered/focused)
    const showPlace = isSpecial || k > 4;

    if (showName) {
      const fs = Math.max(8, Math.min(14, 12 / k));
      ctx.fillStyle = `rgba(42,37,32,${alpha})`;
      ctx.textAlign = 'center';

      // Name
      ctx.font = `${isSpecial ? 'bold ' : ''}${fs}px Georgia`;
      let labelY = d.y - drawR - 3;
      ctx.fillText(d.name, d.x, labelY);

      // Dates line
      if (showDates && (d.birth_year || d.death_date)) {
        const datesFs = fs * 0.78;
        ctx.font = `${datesFs}px Georgia`;
        ctx.fillStyle = `rgba(107,99,96,${alpha})`;
        labelY -= datesFs + 1;
        const parts = [];
        if (d.birth_year) parts.push('b.' + d.birth_year);
        if (d.death_date) { const m = d.death_date.match(/(\d{4})/); if (m) parts.push('d.' + m[1]); }
        ctx.fillText(parts.join(' — '), d.x, labelY);
      }

      // Place line
      if (showPlace && d.birth_place) {
        const placeFs = fs * 0.68;
        ctx.font = `italic ${placeFs}px Georgia`;
        ctx.fillStyle = `rgba(107,99,96,${alpha * 0.7})`;
        labelY -= placeFs + 1;
        // Truncate long places
        const place = d.birth_place.length > 30 ? d.birth_place.slice(0, 28) + '...' : d.birth_place;
        ctx.fillText(place, d.x, labelY);
      }
    }

    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

// ── Resize ──
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width * devicePixelRatio;
  canvas.height = height * devicePixelRatio;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.scale(devicePixelRatio, devicePixelRatio);
  if (simulation) {
    simulation.force('center', d3.forceCenter(width / 2, height / 2));
    simulation.alpha(0.1).restart();
  }
}
window.addEventListener('resize', resize);

// ── Zoom ──
const zoomBehavior = d3.zoom()
  .scaleExtent([0.1, 10])
  .on('zoom', (event) => {
    transform = event.transform;
    draw();
    drawMinimap();
  });

d3.select(canvas).call(zoomBehavior);

// ── Mouse interaction ──
function screenToSim(x, y) {
  return [(x - transform.x) / transform.k, (y - transform.y) / transform.k];
}

function findNode(mx, my) {
  const [sx, sy] = screenToSim(mx, my);
  let closest = null, closestD = Infinity;
  for (const d of nodes) {
    const dx = d.x - sx, dy = d.y - sy;
    const dist = dx * dx + dy * dy;
    const hitR = (nodeRadius(d) + 4) / transform.k;
    if (dist < hitR * hitR && dist < closestD) {
      closest = d;
      closestD = dist;
    }
  }
  return closest;
}

canvas.addEventListener('mousemove', (e) => {
  if (draggedNode) {
    const [sx, sy] = screenToSim(e.clientX, e.clientY);
    draggedNode.fx = sx;
    draggedNode.fy = sy;
    simulation.alpha(0.1).restart();
    return;
  }

  const node = findNode(e.clientX, e.clientY);
  if (node !== hoveredNode) {
    hoveredNode = node;
    canvas.style.cursor = node ? 'pointer' : 'grab';
    draw();
    if (node) showTooltip(node, e.clientX, e.clientY);
    else tooltip.style.opacity = 0;
  } else if (node) {
    tooltip.style.left = (e.clientX + 15) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  }
});

function showTooltip(node, mx, my) {
  const dates = [];
  if (node.birth_year) dates.push('b. ' + node.birth_year);
  if (node.death_date) { const m = node.death_date.match(/(\d{4})/); if (m) dates.push('d. ' + m[1]); }

  const parents = [], children = [], spouses = [];
  for (const l of links) {
    const s = l.source.id ?? l.source, t = l.target.id ?? l.target;
    if (l.type === 'parent_child') {
      if (s === node.id) { const c = nodes.find(n => n.id === t); if (c) children.push(c.name); }
      if (t === node.id) { const p = nodes.find(n => n.id === s); if (p) parents.push(p.name); }
    }
    if (l.type === 'spouse') {
      if (s === node.id) { const sp = nodes.find(n => n.id === t); if (sp) spouses.push(sp.name); }
      if (t === node.id) { const sp = nodes.find(n => n.id === s); if (sp) spouses.push(sp.name); }
    }
  }

  let rels = '';
  if (parents.length) rels += 'Parents: ' + parents.join(', ') + '<br>';
  if (spouses.length) rels += 'Spouse: ' + spouses.join(', ') + '<br>';
  if (children.length) rels += 'Children: ' + children.join(', ');

  const genDist = generationMap.has(node.id) ? generationMap.get(node.id) : null;
  tooltip.innerHTML =
    `<div class="t-name">${node.name}</div>` +
    (dates.length ? `<div class="t-dates">${dates.join(' — ')}</div>` : '') +
    (node.birth_place ? `<div class="t-place">${node.birth_place}</div>` : '') +
    (rels ? `<div class="t-rels">${rels}</div>` : '') +
    (genDist !== null ? `<div class="t-conf">${genDist} step${genDist !== 1 ? 's' : ''} from Ryan</div>` : '') +
    `<div class="t-conf">${node.confidence_tier || 'unknown'} confidence (${node.confidence || '?'}%)${!node.death_date ? ' · <span style="color:#4a8c5c">living</span>' : ''}</div>`;
  tooltip.style.opacity = 1;
  tooltip.style.left = (mx + 15) + 'px';
  tooltip.style.top = (my - 10) + 'px';
}

// ── Drag ──
let mouseDownPos = null;
canvas.addEventListener('mousedown', (e) => {
  mouseDownPos = { x: e.clientX, y: e.clientY };
  const node = findNode(e.clientX, e.clientY);
  if (node) {
    draggedNode = node;
    draggedNode.fx = draggedNode.x;
    draggedNode.fy = draggedNode.y;
    simulation.alphaTarget(0.3).restart();
    d3.select(canvas).on('.zoom', null);
  }
});

canvas.addEventListener('mouseup', () => {
  if (draggedNode) {
    draggedNode.fx = null;
    draggedNode.fy = null;
    draggedNode = null;
    simulation.alphaTarget(0);
    d3.select(canvas).call(zoomBehavior);
  }
});

// Click to focus (distinguish from drag)
canvas.addEventListener('click', (e) => {
  if (mouseDownPos) {
    const dx = e.clientX - mouseDownPos.x, dy = e.clientY - mouseDownPos.y;
    if (dx * dx + dy * dy > 25) return;
  }
  const node = findNode(e.clientX, e.clientY);
  if (node) focusOnNode(node);
});

// Double-click to chain-navigate (re-focus on double-clicked node)
canvas.addEventListener('dblclick', (e) => {
  e.preventDefault();
  const node = findNode(e.clientX, e.clientY);
  if (node) {
    focusOnNode(node);
    // Auto-show path from Ryan
    const ryan = allNodes.find(n => n.id === 58);
    if (ryan && ryan.id !== node.id) {
      const path = findPathBFS(ryan.id, node.id);
      if (path) showPath(path);
    }
  }
});

// Right-click: path finding between two people
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const node = findNode(e.clientX, e.clientY);
  if (!node) { pathStartNode = null; return; }

  if (!pathStartNode) {
    pathStartNode = node;
    // Show hint in focus bar area
    const bar = document.getElementById('pathBar');
    bar.innerHTML = `<span style="opacity:0.8">Path from <strong>${node.name}</strong> → right-click another person</span>` +
      `<button class="path-close" onclick="clearPath(); pathStartNode=null;">✕</button>`;
    bar.style.display = 'flex';
  } else {
    const path = findPathBFS(pathStartNode.id, node.id);
    if (path) {
      showPath(path);
      // Also ensure path nodes are visible: focus on the start if needed
      const pathNodeIds = new Set(path);
      const allVisible = path.every(id => nodes.find(n => n.id === id));
      if (!allVisible) {
        // Show full graph to display the path
        clearFocus();
        setTimeout(() => {
          showPath(path);
          draw();
        }, 300);
      }
    } else {
      const bar = document.getElementById('pathBar');
      bar.innerHTML = `<span style="opacity:0.8">No connection found between <strong>${pathStartNode.name}</strong> and <strong>${node.name}</strong></span>` +
        `<button class="path-close" onclick="clearPath()">✕</button>`;
      bar.style.display = 'flex';
    }
    pathStartNode = null;
  }
});

canvas.addEventListener('mouseleave', () => {
  hoveredNode = null;
  tooltip.style.opacity = 0;
  draw();
});

// ── Controls ──
document.getElementById('viewMode').addEventListener('change', loadGraph);
document.getElementById('colorMode').addEventListener('change', () => { updateLegend(); draw(); });

document.getElementById('sizeSlider').addEventListener('input', (e) => {
  sizeMult = parseFloat(e.target.value);
  document.getElementById('sizeVal').textContent = sizeMult.toFixed(1);
  if (simulation) {
    simulation.force('collision', d3.forceCollide(d => nodeRadius(d) + userCollPad));
    simulation.alpha(0.3).restart();
  }
  draw();
});

document.getElementById('distSlider').addEventListener('input', (e) => {
  userLinkDist = parseInt(e.target.value);
  document.getElementById('distVal').textContent = userLinkDist;
  if (simulation) {
    simulation.force('link')
      .distance(d => d.type === 'spouse' ? userLinkDist * 0.5 : userLinkDist);
    simulation.alpha(0.4).restart();
  }
});

document.getElementById('chargeSlider').addEventListener('input', (e) => {
  userCharge = parseInt(e.target.value);
  document.getElementById('chargeVal').textContent = userCharge;
  if (simulation) {
    simulation.force('charge', d3.forceManyBody().strength(-userCharge));
    simulation.alpha(0.4).restart();
  }
});

document.getElementById('gravSlider').addEventListener('input', (e) => {
  userGravity = parseInt(e.target.value);
  document.getElementById('gravVal').textContent = userGravity;
  if (simulation) {
    simulation.force('x', d3.forceX(width / 2).strength(userGravity / 100));
    simulation.force('y', d3.forceY(height / 2).strength(userGravity / 100));
    simulation.alpha(0.4).restart();
  }
});

document.getElementById('collSlider').addEventListener('input', (e) => {
  userCollPad = parseInt(e.target.value);
  document.getElementById('collVal').textContent = userCollPad;
  if (simulation) {
    simulation.force('collision', d3.forceCollide(d => nodeRadius(d) + userCollPad));
    simulation.alpha(0.3).restart();
  }
});

document.getElementById('resetBtn').addEventListener('click', () => {
  transform = d3.zoomIdentity;
  d3.select(canvas).call(zoomBehavior.transform, d3.zoomIdentity);
  userLinkDist = null; userCharge = null; userGravity = null; userCollPad = 1;
  clearFocus();
});

function fitAllNodes(animate) {
  if (!nodes.length) return;
  const pad = 40;
  let x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  nodes.forEach(n => {
    const r = nodeRadius(n);
    if (n.x - r < x0) x0 = n.x - r;
    if (n.y - r < y0) y0 = n.y - r;
    if (n.x + r > x1) x1 = n.x + r;
    if (n.y + r > y1) y1 = n.y + r;
  });
  const bw = x1 - x0, bh = y1 - y0;
  if (bw <= 0 || bh <= 0) return;
  const k = Math.min((width - pad * 2) / bw, (height - pad * 2) / bh, 10);
  const cx = (x0 + x1) / 2, cy = (y0 + y1) / 2;
  const tx = width / 2 - cx * k, ty = height / 2 - cy * k;
  const t = d3.zoomIdentity.translate(tx, ty).scale(k);
  if (animate) {
    d3.select(canvas).transition().duration(1200).ease(d3.easeCubicInOut).call(zoomBehavior.transform, t);
  } else {
    transform = t;
    d3.select(canvas).call(zoomBehavior.transform, t);
  }
}

document.getElementById('recenterBtn').addEventListener('click', () => fitAllNodes(true));

document.getElementById('autoCenterBtn').addEventListener('click', () => {
  autoCenter = !autoCenter;
  const btn = document.getElementById('autoCenterBtn');
  btn.style.opacity = autoCenter ? '1' : '0.5';
  btn.style.background = autoCenter ? 'rgba(255,255,255,0.25)' : '';
  if (autoCenter) fitAllNodes(true);
});

document.getElementById('focusClear').addEventListener('click', clearFocus);

function updateLegend() {
  const mode = document.getElementById('colorMode').value;
  const el = document.getElementById('legend');
  const linkLeg =
    '<div class="legend-item"><div class="legend-line" style="border-color:var(--accent);opacity:0.5"></div> Parent</div>' +
    '<div class="legend-item"><div class="legend-line dashed" style="border-color:var(--red);opacity:0.5"></div> Spouse</div>';

  if (mode === 'confidence') {
    el.innerHTML =
      '<div class="legend-item"><div class="legend-dot" style="background:#4a8c5c"></div> High</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:#c49a2a"></div> Medium</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:#b85450"></div> Low</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:#8855aa"></div> Speculative</div>' + linkLeg;
  } else if (mode === 'surname') {
    const top = surnameColorScale.domain().slice(0, 5);
    el.innerHTML = top.map(s =>
      `<div class="legend-item"><div class="legend-dot" style="background:${surnameColorScale(s)}"></div> ${s}</div>`
    ).join('') +
    `<div class="legend-item" style="opacity:0.5">+${Math.max(0, surnameColorScale.domain().length - 5)} more</div>` + linkLeg;
  } else if (mode === 'generation') {
    el.innerHTML =
      `<div class="legend-item"><div class="legend-dot" style="background:${genScale(0)}"></div> Ryan (0)</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${genScale(1)}"></div> 1 step</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${genScale(3)}"></div> 3 steps</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${genScale(6)}"></div> 6 steps</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${genScale(10)}"></div> 10+ steps</div>` +
      '<div class="legend-item"><div class="legend-dot" style="background:#ddd"></div> Unconnected</div>' +
      linkLeg;
  } else if (mode === 'century') {
    el.innerHTML =
      Object.entries(centuryColors).map(([k, c]) =>
        `<div class="legend-item"><div class="legend-dot" style="background:${c}"></div> ${k}</div>`
      ).join('') +
      '<div class="legend-item"><div class="legend-dot" style="background:#ddd"></div> Unknown</div>' + linkLeg;
  } else if (mode === 'region') {
    const shown = ['USA', 'Canada', 'Germany', 'Ireland', 'England', 'France', 'Switzerland', 'Italy'];
    el.innerHTML = shown.map(r =>
      `<div class="legend-item"><div class="legend-dot" style="background:${regionColors[r]}"></div> ${r}</div>`
    ).join('') +
    '<div class="legend-item"><div class="legend-dot" style="background:#aaa"></div> Other</div>' + linkLeg;
  } else if (mode === 'status') {
    el.innerHTML =
      `<div class="legend-item"><div class="legend-dot" style="background:${statusColors.living}"></div> Living</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${statusColors.dead}"></div> Deceased</div>` + linkLeg;
  } else {
    el.innerHTML =
      `<div class="legend-item"><div class="legend-dot" style="background:${sexColors.M}"></div> Male</div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${sexColors.F}"></div> Female</div>` +
      '<div class="legend-item"><div class="legend-dot" style="background:#aaa"></div> Unknown</div>' +
      '<div class="legend-item" style="font-size:0.62rem;opacity:0.6"><span style="display:inline-block;width:8px;height:8px;border:1.5px solid #4a8c5c;border-radius:50%;margin-right:4px"></span> Living</div>' +
      linkLeg;
  }
}

// ── Minimap ──
const minimapCanvas = document.getElementById('minimapCanvas');
const minimapCtx = minimapCanvas.getContext('2d');

function drawMinimap() {
  const dpr = devicePixelRatio;
  const mw = 160 * dpr, mh = 120 * dpr;
  minimapCanvas.width = mw;
  minimapCanvas.height = mh;
  if (!nodes.length) return;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const n of nodes) {
    if (n.x < minX) minX = n.x;
    if (n.x > maxX) maxX = n.x;
    if (n.y < minY) minY = n.y;
    if (n.y > maxY) maxY = n.y;
  }
  const pad = 30;
  const rangeX = (maxX - minX + pad * 2) || 1;
  const rangeY = (maxY - minY + pad * 2) || 1;
  const scale = Math.min(mw / rangeX, mh / rangeY);
  const ox = (mw - rangeX * scale) / 2;
  const oy = (mh - rangeY * scale) / 2;

  minimapCtx.clearRect(0, 0, mw, mh);

  // Draw links as faint lines
  minimapCtx.strokeStyle = 'rgba(0,0,0,0.06)';
  minimapCtx.lineWidth = 0.5;
  for (const l of links) {
    if (typeof l.source.x === 'undefined') continue;
    minimapCtx.beginPath();
    minimapCtx.moveTo((l.source.x - minX + pad) * scale + ox, (l.source.y - minY + pad) * scale + oy);
    minimapCtx.lineTo((l.target.x - minX + pad) * scale + ox, (l.target.y - minY + pad) * scale + oy);
    minimapCtx.stroke();
  }

  // Draw nodes
  for (const n of nodes) {
    const x = (n.x - minX + pad) * scale + ox;
    const y = (n.y - minY + pad) * scale + oy;
    minimapCtx.beginPath();
    minimapCtx.arc(x, y, 1.5, 0, Math.PI * 2);
    minimapCtx.fillStyle = (highlightedPath && highlightedPath.includes(n.id)) ? '#e63946' : getColor(n);
    minimapCtx.fill();
  }

  // Draw viewport rectangle
  const vx1 = (0 - transform.x) / transform.k;
  const vy1 = (0 - transform.y) / transform.k;
  const vx2 = (width - transform.x) / transform.k;
  const vy2 = (height - transform.y) / transform.k;
  const rx = (vx1 - minX + pad) * scale + ox;
  const ry = (vy1 - minY + pad) * scale + oy;
  const rw = (vx2 - vx1) * scale;
  const rh = (vy2 - vy1) * scale;

  minimapCtx.strokeStyle = 'rgba(230, 57, 70, 0.7)';
  minimapCtx.lineWidth = 1.5;
  minimapCtx.strokeRect(rx, ry, rw, rh);
}

// Click on minimap to pan
document.getElementById('minimap').addEventListener('click', (e) => {
  if (!nodes.length) return;
  const rect = minimapCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const n of nodes) {
    if (n.x < minX) minX = n.x;
    if (n.x > maxX) maxX = n.x;
    if (n.y < minY) minY = n.y;
    if (n.y > maxY) maxY = n.y;
  }
  const pad = 30;
  const rangeX = maxX - minX + pad * 2;
  const rangeY = maxY - minY + pad * 2;
  const simX = minX - pad + mx * rangeX;
  const simY = minY - pad + my * rangeY;

  const tx = width / 2 - simX * transform.k;
  const ty = height / 2 - simY * transform.k;
  d3.select(canvas).transition().duration(1200).ease(d3.easeCubicInOut)
    .call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(transform.k));
});

// ── Init ──
resize();
loadGraph();
</script>
<script src="/data/help-widget.js"></script>
<script>
initHelp({
  title: 'Family Graph',
  intro: 'A force-directed graph showing every person and relationship in the database. Explore connections, find paths between people, and visually navigate the family network.',
  keyboard: [
    { key: '/', action: 'Focus the search bar' },
    { key: 'Escape', action: 'Clear search / close path bar' },
    { key: '?', action: 'Toggle this help panel' }
  ],
  mouse: [
    { key: 'Left-click node', action: 'Focus that person — dims unconnected nodes' },
    { key: 'Double-click node', action: 'Open that person\'s tree page' },
    { key: 'Right-click node', action: 'Start path-finding (right-click a second person to see how related)' },
    { key: 'Hover node', action: 'Highlight their connections and show name label' },
    { key: 'Drag node', action: 'Move that person\'s node' },
    { key: 'Drag background', action: 'Pan the canvas' },
    { key: 'Scroll wheel', action: 'Zoom in/out' },
    { key: 'Click minimap', action: 'Jump to that area of the graph' }
  ],
  sections: [
    { title: 'Focus & Path Finding', icon: '🔗', html: `
      <p><strong>Left-click</strong> any node to focus it — unconnected people fade out, making it easy to see direct family ties.</p>
      <p>To find how two people are related, <strong>right-click</strong> the first person, then <strong>right-click</strong> the second. The path bar at the bottom shows every person and relationship linking them.</p>
      <p>Click the <strong>×</strong> on the path bar or press <strong>Escape</strong> to dismiss it.</p>
    ` },
    { title: 'Controls Panel', icon: '⚙️', html: `
      <p>The panel on the left lets you tune the graph physics:</p>
      <ul>
        <li><strong>Node Size</strong> — Scale all nodes larger or smaller</li>
        <li><strong>Link Distance</strong> — How far apart connected nodes try to stay</li>
        <li><strong>Repulsion</strong> — How strongly nodes push away from each other</li>
        <li><strong>Gravity</strong> — Pull toward center (prevents drift)</li>
        <li><strong>Collision</strong> — Extra padding between nodes</li>
      </ul>
      <p><strong>Reset</strong> returns all sliders to default. <strong>Recenter</strong> zooms to fit all nodes. <strong>Auto</strong> keeps the view fitted as the simulation runs.</p>
    ` },
    { title: 'Color Modes', icon: '🎨', html: `
      <p>Use the <strong>Color</strong> dropdown to change node coloring:</p>
      <ul>
        <li><strong>Sex</strong> — Blue for male, pink for female, gray for unknown</li>
        <li><strong>Generation</strong> — Color by generation depth from the root</li>
        <li><strong>Confidence</strong> — Green/yellow/orange/red based on data quality</li>
      </ul>
      <p>The legend at the bottom updates to match the selected mode.</p>
    ` },
    { title: 'Search', icon: '🔍', html: `
      <p>Type in the search bar (or press <strong>/</strong>) to find people by name. Click a result to zoom to that node and focus it.</p>
    ` },
    { title: 'Minimap', icon: '🗺', html: `
      <p>The minimap in the bottom-right corner shows the full graph at a glance. The white rectangle shows your current viewport. Click anywhere on the minimap to jump to that area.</p>
    ` }
  ]
});
</script>
</body>
</html>
