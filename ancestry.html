<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lack Lineage â€” Ancestry View</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #e8e4dc;
  --card-bg: #ffffff;
  --card-hover: #faf8f5;
  --text: #333333;
  --text2: #706b63;
  --text3: #9e9a93;
  --accent: #457b3b;
  --accent-hover: #3a6b32;
  --accent-light: #e8f0e6;
  --male: #3b74a3;
  --female: #a3527a;
  --border: #d4cfc7;
  --shadow: 0 2px 8px rgba(0,0,0,0.12);
  --shadow-hover: 0 4px 16px rgba(0,0,0,0.18);
  --radius: 8px;
  --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --line-color: #b8b2a8;
}
html, body { height: 100%; overflow: hidden; }
body { font-family: var(--font); color: var(--text); background: var(--bg); }

/* â”€â”€ Header (unified dark bar) â”€â”€ */
.topbar {
  background: #2a2520;
  color: #f8f6f1;
  height: auto;
  padding: 0.75rem 2rem;
  display: flex;
  align-items: center;
  gap: 2rem;
  z-index: 100;
  position: relative;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}
.topbar .logo {
  font-size: 1.1rem;
  font-weight: 700;
  letter-spacing: 0.05em;
  white-space: nowrap;
  text-decoration: none;
  color: #f8f6f1;
  font-family: 'Georgia', 'Times New Roman', serif;
}
.topbar .logo span { font-weight: 300; opacity: 0.6; }

/* Nav tabs */
.topbar nav { display: flex; gap: 0.5rem; }
.topbar nav a {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.2);
  color: #f8f6f1;
  text-decoration: none;
  padding: 0.3rem 0.7rem;
  border-radius: 6px;
  font-size: 0.8rem;
  font-family: 'Georgia', 'Times New Roman', serif;
  transition: all 0.15s;
}
.topbar nav a:hover, .topbar nav a.active {
  background: rgba(255,255,255,0.15);
  border-color: rgba(255,255,255,0.4);
}
.topbar nav a.active { font-weight: bold; }

/* Search in topbar */
.topbar-search {
  margin-left: auto;
  position: relative;
}
.topbar-search input {
  width: 240px;
  padding: 0.4rem 0.8rem 0.4rem 2rem;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 6px;
  font-size: 0.8rem;
  font-family: 'Georgia', 'Times New Roman', serif;
  background: rgba(255,255,255,0.1);
  color: #f8f6f1;
  outline: none;
  transition: all 0.2s;
}
.topbar-search input::placeholder { color: rgba(255,255,255,0.5); }
.topbar-search input:focus { background: rgba(255,255,255,0.95); color: #2a2520; width: 300px; border-color: rgba(255,255,255,0.6); }
.topbar-search input:focus::placeholder { color: #999; }
.topbar-search .search-icon {
  position: absolute;
  left: 0.6rem;
  top: 50%;
  transform: translateY(-50%);
  font-size: 0.85rem;
  opacity: 0.6;
  pointer-events: none;
}
.topbar-search .search-dropdown {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow-hover);
  max-height: 320px;
  overflow-y: auto;
  display: none;
  z-index: 200;
}
.topbar-search .search-dropdown.show { display: block; }
.search-item {
  padding: 0.6rem 0.8rem;
  cursor: pointer;
  border-bottom: 1px solid #f0ede8;
  transition: background 0.1s;
}
.search-item:hover { background: #f7f5f2; }
.search-item:last-child { border-bottom: none; }
.search-item .si-name { font-weight: 600; font-size: 0.85rem; color: var(--text); }
.search-item .si-dates { font-size: 0.75rem; color: var(--text2); }

/* â”€â”€ Breadcrumb / person info bar â”€â”€ */
.info-bar {
  background: #f5f2ec;
  border-bottom: 1px solid var(--border);
  padding: 0.5rem 1.2rem;
  display: flex;
  align-items: center;
  gap: 0.8rem;
  font-size: 0.82rem;
  z-index: 50;
  position: relative;
}
.info-bar .root-name {
  font-weight: 700;
  font-size: 0.95rem;
  color: var(--text);
}
.info-bar .root-dates { color: var(--text2); }
.info-bar .breadcrumb {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  margin-left: auto;
  color: var(--text3);
  font-size: 0.78rem;
}
.info-bar .breadcrumb a {
  color: var(--accent);
  text-decoration: none;
  cursor: pointer;
}
.info-bar .breadcrumb a:hover { text-decoration: underline; }
.info-bar .breadcrumb .sep { opacity: 0.4; }
.back-btn, .home-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 0.25rem 0.5rem;
  cursor: pointer;
  font-family: var(--font);
  font-size: 0.78rem;
  color: var(--text2);
  transition: all 0.15s;
}
.back-btn:hover, .home-btn:hover { background: #fff; border-color: #bbb; color: var(--text); }

/* â”€â”€ SVG canvas â”€â”€ */
#canvas { display: block; cursor: grab; background: var(--bg); }
#canvas:active { cursor: grabbing; }

/* â”€â”€ Person card (rendered as foreignObject in SVG) â”€â”€ */
.person-card {
  width: 200px;
  height: 80px;
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.6rem;
  padding: 0 0.7rem;
  transition: box-shadow 0.2s, transform 0.15s;
  border: 2px solid transparent;
  overflow: hidden;
  user-select: none;
}
.person-card:hover {
  box-shadow: var(--shadow-hover);
  transform: scale(1.02);
}
.person-card.male { border-left: 4px solid var(--male); }
.person-card.female { border-left: 4px solid var(--female); }
.person-card.unknown-sex { border-left: 4px solid var(--text3); }
.person-card.root-card {
  border: 2px solid var(--accent);
  background: var(--accent-light);
}
.person-card.selected {
  outline: 3px solid #e67e22;
  outline-offset: -1px;
  box-shadow: 0 0 0 4px rgba(230,126,34,0.25), var(--shadow-hover) !important;
}
.person-card.dragging { opacity: 0.85; }

/* Avatar silhouette */
.card-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #eae7e0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 1.1rem;
  color: var(--text3);
}
.card-avatar.male-av { background: #dce7f0; color: var(--male); }
.card-avatar.female-av { background: #f0dce7; color: var(--female); }

/* Card text */
.card-info { flex: 1; min-width: 0; }
.card-name {
  font-weight: 600;
  font-size: 0.82rem;
  color: var(--text);
  line-height: 1.2;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.card-dates {
  font-size: 0.72rem;
  color: var(--text2);
  margin-top: 2px;
}
.card-place {
  font-size: 0.68rem;
  color: var(--text3);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Expand indicator on card */
.card-expand {
  position: absolute;
  right: -12px;
  top: 50%;
  transform: translateY(-50%);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--accent);
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  font-weight: 700;
  box-shadow: 0 1px 4px rgba(0,0,0,0.2);
  cursor: pointer;
  z-index: 5;
}

/* â”€â”€ Empty slot (dashed outline for missing parent) â”€â”€ */
.empty-slot {
  width: 200px;
  height: 80px;
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text3);
  font-size: 0.75rem;
  cursor: default;
  background: rgba(255,255,255,0.3);
}

/* â”€â”€ Detail modal â”€â”€ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  z-index: 300;
  display: none;
  align-items: center;
  justify-content: center;
}
.modal-overlay.show { display: flex; }
.modal {
  background: var(--card-bg);
  border-radius: 12px;
  box-shadow: 0 8px 40px rgba(0,0,0,0.25);
  width: 420px;
  max-height: 80vh;
  overflow-y: auto;
  padding: 1.5rem;
  position: relative;
}
.modal-close {
  position: absolute;
  top: 0.8rem;
  right: 0.8rem;
  background: none;
  border: none;
  font-size: 1.3rem;
  cursor: pointer;
  color: var(--text3);
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.15s;
}
.modal-close:hover { background: #f0ede8; color: var(--text); }
.modal h2 { font-size: 1.15rem; margin-bottom: 0.2rem; }
.modal .modal-subtitle { color: var(--text2); font-size: 0.82rem; margin-bottom: 1rem; }
.modal-section { margin-top: 1rem; }
.modal-section h4 { font-size: 0.8rem; color: var(--accent); text-transform: uppercase; letter-spacing: 0.04em; margin-bottom: 0.4rem; }
.modal-section p { font-size: 0.85rem; line-height: 1.6; color: var(--text2); }
.modal-section ul { list-style: none; padding: 0; }
.modal-section li { padding: 0.2rem 0; font-size: 0.85rem; }
.modal-section a { color: var(--accent); cursor: pointer; text-decoration: none; }
.modal-section a:hover { text-decoration: underline; }
.modal-btn {
  display: inline-block;
  margin-top: 0.8rem;
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 0.45rem 1rem;
  border-radius: 6px;
  font-family: var(--font);
  font-size: 0.82rem;
  cursor: pointer;
  transition: background 0.15s;
}
.modal-btn:hover { background: var(--accent-hover); }

/* â”€â”€ Confidence indicators â”€â”€ */
.confidence-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
  margin-left: auto;
}
.confidence-dot.tier-high       { background: #2d9a2d; }
.confidence-dot.tier-medium     { background: #c9a100; }
.confidence-dot.tier-low        { background: #d47a1a; }
.confidence-dot.tier-speculative { background: #c44; }

.confidence-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.2rem 0.6rem;
  border-radius: 12px;
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.02em;
}
.confidence-badge.tier-high {
  background: #e8f5e9; color: #2d7a2d;
}
.confidence-badge.tier-medium {
  background: #fff8e1; color: #8a6d00;
}
.confidence-badge.tier-low {
  background: #fff3e0; color: #b5651d;
}
.confidence-badge.tier-speculative {
  background: #ffebee; color: #c44;
}
.confidence-bar {
  height: 4px;
  border-radius: 2px;
  background: #e0ddd6;
  width: 60px;
  overflow: hidden;
  display: inline-block;
  vertical-align: middle;
  margin-left: 0.3rem;
}
.confidence-bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.3s;
}
.confidence-bar-fill.tier-high       { background: #2d9a2d; }
.confidence-bar-fill.tier-medium     { background: #c9a100; }
.confidence-bar-fill.tier-low        { background: #d47a1a; }
.confidence-bar-fill.tier-speculative { background: #c44; }

/* â”€â”€ Zoom controls â”€â”€ */
.zoom-controls {
  position: fixed;
  bottom: 1.5rem;
  right: 1.5rem;
  z-index: 50;
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
}
.zoom-controls button {
  width: 36px;
  height: 36px;
  background: var(--card-bg);
  border: none;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  font-size: 1.1rem;
  color: var(--text2);
  transition: all 0.1s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.zoom-controls button:last-child { border-bottom: none; }
.zoom-controls button:hover { background: #f0ede8; color: var(--text); }

/* â”€â”€ Generation labels â”€â”€ */
.gen-label {
  font-family: var(--font);
  font-size: 11px;
  fill: var(--text3);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

/* â”€â”€ Loading â”€â”€ */
.loading-overlay {
  position: fixed;
  inset: 0;
  background: rgba(232,228,220,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 250;
}
.loading-overlay.show { display: flex; }
.spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.7s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.sel-count {
  position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%);
  background: rgba(230,126,34,0.9); color: #fff; padding: 0.3rem 0.9rem;
  border-radius: 20px; font-size: 0.78rem; font-weight: 600; z-index: 50;
  pointer-events: none; transition: opacity 0.2s;
}
.sel-count:empty { opacity: 0; }
.marquee { fill: rgba(230,126,34,0.12); stroke: #e67e22; stroke-width: 1.5; stroke-dasharray: 5 3; pointer-events: none; }

@media (max-width: 600px) {
  header { padding: 0.5rem 0.75rem; gap: 0.5rem; flex-wrap: wrap; }
  nav a { padding: 0.2rem 0.45rem; font-size: 0.65rem; }
  .search-input { width: 120px; font-size: 0.75rem; }
  .breadcrumb { font-size: 0.65rem; padding: 0.2rem 0.5rem; }
  .detail-panel { width: 85vw; min-width: unset; }
}
</style>
</head>
<body>

<!-- Top bar -->
<div class="topbar">
  <a href="/" class="logo">Lack <span>Lineage</span></a>
  <nav>
    <a href="/">Dashboard</a>
    <a href="/graph.html">Graph</a>
    <a href="/tree.html">Tree</a>
    <a href="/ancestry.html" class="active">Ancestry</a>
    <a href="/documents.html">Documents</a>
  </nav>
  <div class="topbar-search">
    <span class="search-icon">&#128269;</span>
    <input type="text" id="search" placeholder="Search for a personâ€¦" autocomplete="off">
    <div class="search-dropdown" id="search-dropdown"></div>
  </div>
</div>

<!-- Info bar -->
<div class="info-bar">
  <button class="back-btn" id="btn-back" title="Go back">&#8592; Back</button>
  <button class="home-btn" id="btn-home" title="Return to George">&#8962; Home</button>
  <span class="root-name" id="root-name">â€”</span>
  <span class="root-dates" id="root-dates"></span>
  <div class="breadcrumb" id="breadcrumb"></div>
</div>

<!-- Canvas -->
<svg id="canvas"></svg>

<!-- Zoom controls -->
<div class="zoom-controls">
  <button id="btn-zoomin" title="Zoom in">+</button>
  <button id="btn-zoomout" title="Zoom out">âˆ’</button>
  <button id="btn-fit" title="Fit to view">âŠ¡</button>
  <button id="btn-orient" title="Switch to vertical view">â¬</button>
  <button id="btn-reset" title="Reset card positions">â†º</button>
</div>
<div class="sel-count" id="sel-count"></div>

<!-- Loading overlay -->
<div class="loading-overlay" id="loading">
  <div class="spinner"></div>
</div>

<!-- Detail modal -->
<div class="modal-overlay" id="modal-overlay">
  <div class="modal" id="modal">
    <button class="modal-close" id="modal-close">&times;</button>
    <div id="modal-content"></div>
  </div>
</div>

<script src="/data/lineage-shim.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CARD_W = 200;
const CARD_H = 80;
const H_GAP = 60;        // horizontal gap between generations
const V_GAP = 16;         // minimum vertical gap between cards
const DEFAULT_ROOT = 1; // George l Lack
const DEFAULT_DEPTH = 8;
const GEN_LABELS = ['You', 'Parents', 'Grandparents', 'Gt-Grandparents',
  '2x Gt-Grandparents', '3x Gt-Grandparents', '4x Gt-Grandparents',
  '5x Gt-Grandparents', '6x Gt-Grandparents', '7x Gt-Grandparents',
  '8x Gt-Grandparents', '9x Gt-Grandparents', '10x Gt-Grandparents',
  '11x Gt-Grandparents', '12x Gt-Grandparents'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentRoot = DEFAULT_ROOT;
let depth = DEFAULT_DEPTH;
let history = [];
let treeData = null;
let svg, gMain, zoomBehavior;
let orientation = 'horizontal';
let selectedNodes = new Set();
let currentNodes = [];
let currentLinks = [];
let dragState = null;
let clickTimer = null;
let marqueeState = null;   // {rect, sx, sy} for rectangle selection

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fmtYear(d) {
  if (!d) return '';
  const m = String(d).match(/\b(1[4-9]\d{2}|20[0-2]\d)\b/);
  return m ? m[1] : '';
}

function lifespan(p) {
  const b = fmtYear(p.birth);
  const d = fmtYear(p.death);
  if (!b && !d) return '';
  if (!d) return `b. ${b}`;
  if (!b) return `d. ${d}`;
  return `${b} â€“ ${d}`;
}

function sexClass(s) {
  if (s === 'M') return 'male';
  if (s === 'F') return 'female';
  return 'unknown-sex';
}

function avatarSvg(sex) {
  if (sex === 'M') return `<svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><circle cx="12" cy="8" r="4"/><path d="M12 14c-5 0-8 2.5-8 5v1h16v-1c0-2.5-3-5-8-5z"/></svg>`;
  if (sex === 'F') return `<svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><circle cx="12" cy="8" r="4"/><path d="M12 14c-5 0-8 2.5-8 5v1h16v-1c0-2.5-3-5-8-5z"/></svg>`;
  return `<svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><circle cx="12" cy="8" r="4" opacity="0.5"/><path d="M12 14c-5 0-8 2.5-8 5v1h16v-1c0-2.5-3-5-8-5z" opacity="0.5"/></svg>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SVG INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initCanvas() {
  const el = document.getElementById('canvas');
  const topH = document.querySelector('.topbar').offsetHeight;
  const infoH = document.querySelector('.info-bar').offsetHeight;
  const h = window.innerHeight - topH - infoH;
  el.style.width = '100%';
  el.style.height = h + 'px';

  svg = d3.select('#canvas');
  svg.selectAll('*').remove();

  gMain = svg.append('g').attr('class', 'main-group');

  zoomBehavior = d3.zoom()
    .scaleExtent([0.1, 2.5])
    .filter(event => !event.shiftKey)   // shift+drag = marquee, not pan
    .on('zoom', (event) => gMain.attr('transform', event.transform));
  svg.call(zoomBehavior);

  // â”€â”€ Marquee rectangle selection (shift+drag on background) â”€â”€
  svg.on('mousedown.marquee', function(event) {
    if (!event.shiftKey) return;
    if (event.button !== 0) return;
    event.preventDefault();
    const pt = getSVGPointFromSVG(event);
    const rect = gMain.append('rect').attr('class', 'marquee')
      .attr('x', pt.x).attr('y', pt.y).attr('width', 0).attr('height', 0);
    marqueeState = { rect, sx: pt.x, sy: pt.y };
  });
  svg.on('mousemove.marquee', function(event) {
    if (!marqueeState) return;
    event.preventDefault();
    const pt = getSVGPointFromSVG(event);
    const x = Math.min(marqueeState.sx, pt.x);
    const y = Math.min(marqueeState.sy, pt.y);
    const w = Math.abs(pt.x - marqueeState.sx);
    const h = Math.abs(pt.y - marqueeState.sy);
    marqueeState.rect.attr('x', x).attr('y', y).attr('width', w).attr('height', h);
  });
  svg.on('mouseup.marquee', function(event) {
    if (!marqueeState) return;
    const pt = getSVGPointFromSVG(event);
    const x1 = Math.min(marqueeState.sx, pt.x);
    const y1 = Math.min(marqueeState.sy, pt.y);
    const x2 = Math.max(marqueeState.sx, pt.x);
    const y2 = Math.max(marqueeState.sy, pt.y);
    marqueeState.rect.remove();
    marqueeState = null;

    // Select cards that overlap the rectangle
    if (!event.ctrlKey && !event.metaKey) selectedNodes.clear();
    for (const nd of currentNodes) {
      if (nd.empty) continue;
      const cx = nd.x + CARD_W / 2;
      const cy = nd.y + CARD_H / 2;
      if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) {
        selectedNodes.add(nd.id);
      }
    }
    updateSelectionVisuals();
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PEDIGREE LAYOUT
// Ancestry-style: root left, ancestors fan right
// Each gen: gen0 has 1 slot, gen1 has 2, gen2 has 4, etc.
// Position is deterministic â€” slot i in gen g maps to
// specific y position based on the subtree height.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function layoutPedigree(data, maxGens) {
  const nodes = [];
  const links = [];
  const isVert = orientation === 'vertical';

  function treeDepth(n, d = 0) {
    if (!n) return d;
    const parents = n.parents || [];
    let maxD = d;
    for (const p of parents) maxD = Math.max(maxD, treeDepth(p, d + 1));
    return maxD;
  }

  const actualDepth = Math.min(treeDepth(data) + 1, maxGens);
  // Slot size along the spread axis
  const slotSize = isVert ? (CARD_W + 24) : (CARD_H + V_GAP);
  const genStep  = isVert ? (CARD_H + 60) : (CARD_W + H_GAP);
  const actualLeaves = Math.pow(2, actualDepth - 1);
  const totalSpan = actualLeaves * slotSize;

  function place(node, gen, spanMin, spanMax) {
    if (!node) return null;
    const spanMid = (spanMin + spanMax) / 2;
    let x, y, yMid;
    if (isVert) {
      x = spanMid - CARD_W / 2;
      y = -gen * genStep;
      yMid = y + CARD_H / 2;
    } else {
      x = gen * genStep;
      y = spanMid - CARD_H / 2;
      yMid = spanMid;
    }

    const positioned = { ...node, x, y, yMid, gen,
      hasHiddenParents: !!(node._parents && node._parents.length > 0) };
    nodes.push(positioned);

    const parents = node.parents || [];
    if (parents.length > 0 || gen < actualDepth - 1) {
      const father = parents[0] || null;
      const mother = parents[1] || null;
      const halfSpan = (spanMax - spanMin) / 2;

      if (father) {
        const fNode = place(father, gen + 1, spanMin, spanMin + halfSpan);
        if (fNode) links.push({ source: positioned, target: fNode });
      } else if (gen < actualDepth - 1) {
        let ex, ey;
        if (isVert) { ex = (spanMin + spanMin + halfSpan)/2 - CARD_W/2; ey = -(gen+1)*genStep; }
        else { ex = (gen+1)*genStep; ey = (spanMin + spanMin + halfSpan)/2 - CARD_H/2; }
        nodes.push({ id: `empty-f-${node.id}-${gen}`, empty: true, x: ex, y: ey, yMid: ey + CARD_H/2, gen: gen+1 });
      }

      if (mother) {
        const mNode = place(mother, gen + 1, spanMin + halfSpan, spanMax);
        if (mNode) links.push({ source: positioned, target: mNode });
      } else if (gen < actualDepth - 1) {
        let ex, ey;
        if (isVert) { ex = (spanMin + halfSpan + spanMax)/2 - CARD_W/2; ey = -(gen+1)*genStep; }
        else { ex = (gen+1)*genStep; ey = (spanMin + halfSpan + spanMax)/2 - CARD_H/2; }
        nodes.push({ id: `empty-m-${node.id}-${gen}`, empty: true, x: ex, y: ey, yMid: ey + CARD_H/2, gen: gen+1 });
      }
    }
    return positioned;
  }

  place(data, 0, 0, totalSpan);
  const totalW = isVert ? totalSpan : actualDepth * genStep;
  const totalH = isVert ? actualDepth * genStep : totalSpan;
  return { nodes, links, totalW, totalH };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FETCH & RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchAncestors(rootId, depth) {
  document.getElementById('loading').classList.add('show');
  try {
    const resp = await fetch(`/api/ancestors?id=${rootId}&depth=${depth}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    if (data.error) throw new Error(data.error);
    return data;
  } catch (err) {
    console.error('Fetch error:', err);
    return null;
  } finally {
    document.getElementById('loading').classList.remove('show');
  }
}

async function loadAndRender() {
  const data = await fetchAncestors(currentRoot, depth);
  if (!data) return;
  treeData = data;
  render(data);
  updateInfoBar(data);
  updateURL();
  setTimeout(fitToView, 50);
}

function render(data) {
  gMain.selectAll('*').remove();
  selectedNodes.clear();
  currentNodes = [];
  currentLinks = [];

  const layout = layoutPedigree(data, depth);
  currentNodes = layout.nodes;
  currentLinks = layout.links;
  const isVert = orientation === 'vertical';
  const genStep = isVert ? (CARD_H + 60) : (CARD_W + H_GAP);

  // â”€â”€ Generation labels â”€â”€
  const gensUsed = [...new Set(currentNodes.map(n => n.gen))];
  for (const gen of gensUsed) {
    if (isVert) {
      const minX = currentNodes.filter(n => n.gen === gen && !n.empty)
        .reduce((m, n) => Math.min(m, n.x), Infinity);
      gMain.append('text').attr('class', 'gen-label')
        .attr('x', (minX === Infinity ? 0 : minX) - 20)
        .attr('y', -gen * genStep + CARD_H / 2)
        .attr('text-anchor', 'end').attr('dominant-baseline', 'middle')
        .text(GEN_LABELS[gen] || `Gen ${gen}`);
    } else {
      gMain.append('text').attr('class', 'gen-label')
        .attr('x', gen * genStep + CARD_W / 2).attr('y', -20)
        .attr('text-anchor', 'middle')
        .text(GEN_LABELS[gen] || `Gen ${gen}`);
    }
  }

  // â”€â”€ Connection lines â”€â”€
  gMain.append('g').attr('class', 'connections');
  updateLines();

  // â”€â”€ Cards â”€â”€
  const cardGroup = gMain.append('g').attr('class', 'cards');

  // Empty slots
  for (const node of currentNodes.filter(n => n.empty)) {
    const fo = cardGroup.append('foreignObject')
      .attr('x', node.x).attr('y', node.y)
      .attr('width', CARD_W).attr('height', CARD_H);
    fo.append('xhtml:div').attr('class', 'empty-slot')
      .html('<span>Unknown</span>');
  }

  // Person cards via D3 data join (enables drag)
  const realNodes = currentNodes.filter(n => !n.empty);
  const cardFOs = cardGroup.selectAll('.card-fo')
    .data(realNodes, d => d.id)
    .join('foreignObject')
    .attr('class', 'card-fo')
    .attr('data-node-id', d => d.id)
    .attr('x', d => d.x).attr('y', d => d.y)
    .attr('width', CARD_W).attr('height', CARD_H)
    .style('overflow', 'visible');

  cardFOs.each(function(d) {
    const isRoot = d.gen === 0;
    const sexCls = sexClass(d.sex);
    const avCls = d.sex === 'M' ? 'male-av' : d.sex === 'F' ? 'female-av' : '';
    d3.select(this).append('xhtml:div')
      .attr('class', `person-card ${sexCls} ${isRoot ? 'root-card' : ''}`)
      .attr('data-id', d.id)
      .html(`
        <div class="card-avatar ${avCls}">${avatarSvg(d.sex)}</div>
        <div class="card-info">
          <div class="card-name" title="${d.name || 'Unknown'}">${d.name || 'Unknown'}</div>
          <div class="card-dates">${lifespan(d)}</div>
        </div>
        <div class="confidence-dot tier-${d.confidence_tier || 'speculative'}" title="Confidence: ${d.confidence || 0}% (${(d.confidence_tier || 'speculative').toUpperCase()})"></div>
      `);
  });

  // â”€â”€ Drag behaviour â”€â”€
  cardFOs.call(d3.drag()
    .on('start', dragStarted)
    .on('drag', dragged)
    .on('end', dragEnded)
  );

  // â”€â”€ Click = select / Dbl-click = navigate â”€â”€
  cardFOs.on('click', function(event, d) {
    event.stopPropagation();
    clearTimeout(clickTimer);
    const ctrl = event.ctrlKey || event.metaKey;
    const shift = event.shiftKey;
    clickTimer = setTimeout(() => {
      if (ctrl) {
        if (selectedNodes.has(d.id)) selectedNodes.delete(d.id);
        else selectedNodes.add(d.id);
      } else if (shift) {
        selectedNodes.add(d.id);
      } else {
        selectedNodes.clear();
        selectedNodes.add(d.id);
      }
      updateSelectionVisuals();
    }, 220);
  });

  cardFOs.on('dblclick', function(event, d) {
    event.stopPropagation();
    event.preventDefault();
    clearTimeout(clickTimer);
    navigateTo(d.id, d.name);
  });

  cardFOs.on('contextmenu', function(event, d) {
    event.preventDefault();
    showModal(d.id);
  });

  // Deselect on background click
  svg.on('click.select', function(event) {
    if (event.target === svg.node() || event.target.tagName === 'svg') {
      selectedNodes.clear();
      updateSelectionVisuals();
    }
  });

  updateSelectionVisuals();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAG & SELECT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getSVGPoint(sourceEvent) {
  const pt = svg.node().createSVGPoint();
  pt.x = sourceEvent.clientX;
  pt.y = sourceEvent.clientY;
  const ctm = gMain.node().getScreenCTM();
  return ctm ? pt.matrixTransform(ctm.inverse()) : pt;
}

// Same as getSVGPoint but takes a raw MouseEvent (not d3.drag sourceEvent)
function getSVGPointFromSVG(event) {
  const pt = svg.node().createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  const ctm = gMain.node().getScreenCTM();
  return ctm ? pt.matrixTransform(ctm.inverse()) : pt;
}

function dragStarted(event, d) {
  event.sourceEvent.stopPropagation();
  // Auto-select if not in selection
  if (!selectedNodes.has(d.id)) {
    selectedNodes.clear();
    selectedNodes.add(d.id);
    updateSelectionVisuals();
  }
  const pt = getSVGPoint(event.sourceEvent);
  dragState = { starts: new Map(), sx: pt.x, sy: pt.y };
  for (const nd of currentNodes) {
    if (selectedNodes.has(nd.id)) {
      dragState.starts.set(nd.id, { x: nd.x, y: nd.y, yMid: nd.yMid });
    }
  }
  // Visual feedback
  for (const id of selectedNodes) {
    gMain.select(`[data-node-id="${id}"]`).select('.person-card').classed('dragging', true);
  }
}

function dragged(event, d) {
  if (!dragState) return;
  const pt = getSVGPoint(event.sourceEvent);
  const dx = pt.x - dragState.sx;
  const dy = pt.y - dragState.sy;
  for (const [id, start] of dragState.starts) {
    const nd = currentNodes.find(n => n.id === id);
    if (!nd) continue;
    nd.x = start.x + dx;
    nd.y = start.y + dy;
    nd.yMid = start.yMid + dy;
    gMain.select(`[data-node-id="${id}"]`).attr('x', nd.x).attr('y', nd.y);
  }
  updateLines();
}

function dragEnded(event, d) {
  dragState = null;
  gMain.selectAll('.person-card.dragging').classed('dragging', false);
}

function updateLines() {
  const lineGroup = gMain.select('.connections');
  if (lineGroup.empty()) return;
  const isVert = orientation === 'vertical';
  lineGroup.selectAll('path')
    .data(currentLinks)
    .join('path')
    .attr('d', link => {
      const s = link.source, t = link.target;
      if (isVert) {
        const sx = s.x + CARD_W/2, sy = s.y;
        const tx = t.x + CARD_W/2, ty = t.y + CARD_H;
        const my = sy + (ty - sy) * 0.5;
        return `M${sx},${sy} C${sx},${my} ${tx},${my} ${tx},${ty}`;
      } else {
        const sx = s.x + CARD_W, sy = s.yMid;
        const tx = t.x, ty = t.yMid;
        const mx = sx + (tx - sx) * 0.5;
        return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
      }
    })
    .attr('fill', 'none')
    .attr('stroke', 'var(--line-color)')
    .attr('stroke-width', 2)
    .attr('opacity', 0.7);
}

function updateSelectionVisuals() {
  gMain.selectAll('.card-fo').each(function(d) {
    d3.select(this).select('.person-card').classed('selected', selectedNodes.has(d.id));
  });
  const el = document.getElementById('sel-count');
  if (el) el.textContent = selectedNodes.size > 0 ? `${selectedNodes.size} selected` : '';
}

function toggleOrientation() {
  orientation = orientation === 'horizontal' ? 'vertical' : 'horizontal';
  const btn = document.getElementById('btn-orient');
  btn.textContent = orientation === 'horizontal' ? 'â¬' : 'â¬Œ';
  btn.title = orientation === 'horizontal' ? 'Switch to vertical view' : 'Switch to horizontal view';
  if (treeData) { render(treeData); setTimeout(fitToView, 50); }
}

function resetPositions() {
  if (treeData) { render(treeData); setTimeout(fitToView, 50); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function navigateTo(id, name) {
  if (id === currentRoot) return;
  history.push({ id: currentRoot, name: document.getElementById('root-name').textContent });
  currentRoot = id;
  loadAndRender();
}

function goBack() {
  if (history.length === 0) return;
  const prev = history.pop();
  currentRoot = prev.id;
  loadAndRender();
}

function goHome() {
  if (currentRoot === DEFAULT_ROOT) return;
  history.push({ id: currentRoot, name: document.getElementById('root-name').textContent });
  currentRoot = DEFAULT_ROOT;
  loadAndRender();
}

function updateInfoBar(data) {
  document.getElementById('root-name').textContent = data.name || 'Unknown';
  document.getElementById('root-dates').textContent = lifespan(data);

  // Breadcrumb
  const bc = document.getElementById('breadcrumb');
  if (history.length === 0) {
    bc.innerHTML = '';
    return;
  }
  const trail = history.slice(-4); // show last 4
  let html = '';
  if (history.length > 4) html += '<span class="sep">â€¦</span> <span class="sep">â€º</span> ';
  trail.forEach((h, i) => {
    html += `<a data-idx="${history.length - trail.length + i}">${h.name}</a>`;
    html += ' <span class="sep">â€º</span> ';
  });
  html += `<strong>${data.name}</strong>`;
  bc.innerHTML = html;

  bc.querySelectorAll('a').forEach(a => {
    a.addEventListener('click', () => {
      const idx = parseInt(a.dataset.idx);
      const target = history[idx];
      // Truncate history to that point
      history = history.slice(0, idx);
      currentRoot = target.id;
      loadAndRender();
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETAIL MODAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function showModal(personId) {
  const overlay = document.getElementById('modal-overlay');
  const content = document.getElementById('modal-content');
  content.innerHTML = '<p style="color:var(--text3)">Loadingâ€¦</p>';
  overlay.classList.add('show');

  try {
    const resp = await fetch(`/api/person/${personId}`);
    const d = await resp.json();

    let html = `<h2>${d.given_name || ''} ${d.surname || ''}</h2>`;
    html += `<div class="modal-subtitle">ID ${d.id}`;
    const tier = d.confidence_tier || 'speculative';
    const conf = d.confidence || 0;
    const tierLabel = tier.charAt(0).toUpperCase() + tier.slice(1);
    html += ` <span class="confidence-badge tier-${tier}">${tierLabel} ${conf}%`;
    html += `<span class="confidence-bar"><span class="confidence-bar-fill tier-${tier}" style="width:${conf}%"></span></span>`;
    html += `</span></div>`;

    html += '<div class="modal-section"><h4>Vital Information</h4>';
    if (d.birth_date || d.birth_place) {
      html += `<p><strong>Born:</strong> ${d.birth_date || '?'}`;
      if (d.birth_place) html += ` â€” ${d.birth_place}`;
      html += '</p>';
    }
    if (d.death_date || d.death_place) {
      html += `<p><strong>Died:</strong> ${d.death_date || '?'}`;
      if (d.death_place) html += ` â€” ${d.death_place}`;
      html += '</p>';
    }
    if (d.sex) html += `<p><strong>Sex:</strong> ${d.sex === 'M' ? 'Male' : d.sex === 'F' ? 'Female' : d.sex}</p>`;
    html += '</div>';

    if (d.parents && d.parents.length > 0) {
      html += '<div class="modal-section"><h4>Parents</h4><ul>';
      for (const p of d.parents) {
        html += `<li><a data-nav="${p.id}">${p.given_name || ''} ${p.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    if (d.spouses && d.spouses.length > 0) {
      html += '<div class="modal-section"><h4>Spouses</h4><ul>';
      for (const s of d.spouses) {
        html += `<li><a data-nav="${s.id}">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    if (d.children && d.children.length > 0) {
      html += '<div class="modal-section"><h4>Children</h4><ul>';
      for (const c of d.children) {
        html += `<li><a data-nav="${c.id}">${c.given_name || ''} ${c.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    if (d.siblings && d.siblings.length > 0) {
      html += '<div class="modal-section"><h4>Siblings</h4><ul>';
      for (const s of d.siblings) {
        html += `<li><a data-nav="${s.id}">${s.given_name || ''} ${s.surname || ''}</a></li>`;
      }
      html += '</ul></div>';
    }

    html += `<button class="modal-btn" data-nav="${d.id}">View tree from this person</button>`;
    content.innerHTML = html;

    // Wire up nav links inside modal
    content.querySelectorAll('[data-nav]').forEach(el => {
      el.addEventListener('click', () => {
        overlay.classList.remove('show');
        navigateTo(parseInt(el.dataset.nav), el.textContent.trim());
      });
    });

  } catch (err) {
    content.innerHTML = `<p style="color:#c44">Error: ${err.message}</p>`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEARCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let searchTimer = null;
const searchInput = document.getElementById('search');
const searchDropdown = document.getElementById('search-dropdown');

searchInput.addEventListener('input', function() {
  clearTimeout(searchTimer);
  const q = this.value.trim();
  if (q.length < 2) {
    searchDropdown.classList.remove('show');
    return;
  }
  searchTimer = setTimeout(async () => {
    try {
      const resp = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
      const results = await resp.json();
      if (results.length === 0) {
        searchDropdown.innerHTML = '<div class="search-item"><span class="si-dates">No results</span></div>';
      } else {
        searchDropdown.innerHTML = results.slice(0, 12).map(p => {
          const name = `${p.given_name || ''} ${p.surname || ''}`.trim() || 'Unknown';
          const dates = [p.birth_date, p.death_date].filter(Boolean).join(' â€“ ') || 'no dates';
          return `<div class="search-item" data-id="${p.id}" data-name="${name}">
            <div class="si-name">${name}</div>
            <div class="si-dates">${dates}</div>
          </div>`;
        }).join('');
      }
      searchDropdown.classList.add('show');
    } catch (e) {
      searchDropdown.classList.remove('show');
    }
  }, 200);
});

searchDropdown.addEventListener('click', function(e) {
  const item = e.target.closest('.search-item');
  if (item && item.dataset.id) {
    searchDropdown.classList.remove('show');
    searchInput.value = item.dataset.name;
    navigateTo(parseInt(item.dataset.id), item.dataset.name);
  }
});

document.addEventListener('click', e => {
  if (!e.target.closest('.topbar-search')) {
    searchDropdown.classList.remove('show');
  }
});

searchInput.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    searchDropdown.classList.remove('show');
    this.blur();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZOOM CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function fitToView() {
  const bounds = gMain.node().getBBox();
  if (bounds.width === 0 || bounds.height === 0) return;
  const el = document.getElementById('canvas');
  const w = el.clientWidth;
  const h = el.clientHeight;
  const pad = 80;
  const scale = Math.min(
    (w - pad * 2) / bounds.width,
    (h - pad * 2) / bounds.height,
    1.2
  );
  const tx = (w - bounds.width * scale) / 2 - bounds.x * scale;
  const ty = (h - bounds.height * scale) / 2 - bounds.y * scale;
  svg.transition().duration(400)
    .call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

document.getElementById('btn-zoomin').addEventListener('click', () =>
  svg.transition().duration(200).call(zoomBehavior.scaleBy, 1.4));
document.getElementById('btn-zoomout').addEventListener('click', () =>
  svg.transition().duration(200).call(zoomBehavior.scaleBy, 0.7));
document.getElementById('btn-fit').addEventListener('click', fitToView);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('btn-back').addEventListener('click', goBack);
document.getElementById('btn-home').addEventListener('click', goHome);
document.getElementById('btn-orient').addEventListener('click', toggleOrientation);
document.getElementById('btn-reset').addEventListener('click', resetPositions);
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') { selectedNodes.clear(); updateSelectionVisuals(); }
});

document.getElementById('modal-close').addEventListener('click', () =>
  document.getElementById('modal-overlay').classList.remove('show'));
document.getElementById('modal-overlay').addEventListener('click', function(e) {
  if (e.target === this) this.classList.remove('show');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// URL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateURL() {
  const params = new URLSearchParams();
  if (currentRoot !== DEFAULT_ROOT) params.set('root', currentRoot);
  if (depth !== DEFAULT_DEPTH) params.set('depth', depth);
  const qs = params.toString();
  window.history.replaceState(null, '', window.location.pathname + (qs ? '?' + qs : ''));
}

function readURL() {
  const params = new URLSearchParams(window.location.search);
  if (params.has('root')) currentRoot = parseInt(params.get('root'));
  if (params.has('depth')) depth = parseInt(params.get('depth'));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('resize', () => {
  const topH = document.querySelector('.topbar').offsetHeight;
  const infoH = document.querySelector('.info-bar').offsetHeight;
  document.getElementById('canvas').style.height = (window.innerHeight - topH - infoH) + 'px';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

readURL();
initCanvas();
loadAndRender();
</script>
<script src="/data/help-widget.js"></script>
<script>
initHelp({
  title: 'Ancestry Chart',
  intro: 'A pedigree chart showing ancestors fanning out from a root person. Navigate through generations, select and rearrange cards, and switch between horizontal and vertical layouts.',
  keys: [
    { key: 'Click', action: 'Select a person card' },
    { key: 'Ctrl + Click', action: 'Toggle card in/out of selection' },
    { key: 'Shift + Click', action: 'Add card to selection' },
    { key: 'Double-click', action: 'Navigate to that person as new root' },
    { key: 'Right-click', action: 'Open detail modal for that person' },
    { key: 'Drag card', action: 'Move selected card(s) â€” lines follow' },
    { key: 'Shift + Drag background', action: 'Draw rectangle to select multiple cards' },
    { key: 'Ctrl + Release marquee', action: 'Add marquee cards to existing selection' },
    { key: 'Scroll wheel', action: 'Zoom in/out (when hovering canvas)' },
    { key: 'Drag background', action: 'Pan the canvas' },
    { key: 'Escape', action: 'Deselect all cards' },
    { key: '?', action: 'Toggle this help panel' }
  ],
  sections: [
    { title: 'Navigation', icon: 'ğŸ§­', html: `
      <p>The chart starts at <strong>George l Lack</strong> (the root). Click any person card to select it, then <strong>double-click</strong> to make that person the new root. The chart rebuilds to show their ancestors.</p>
      <p>Use the <strong>â† Back</strong> button or breadcrumb trail to return to previous roots. <strong>âŒ‚ Home</strong> returns to George.</p>
      <p>The URL updates with <code>?root=</code> and <code>?depth=</code> parameters â€” you can bookmark or share any view.</p>
    ` },
    { title: 'Selection & Dragging', icon: 'âœ‹', html: `
      <p><strong>Click</strong> a card to select it (orange highlight). Hold <strong>Ctrl</strong> and click to toggle additional cards. Hold <strong>Shift</strong> and click to add to the selection.</p>
      <p><strong>Drag</strong> any selected card to move all selected cards together. Connection lines update in real time.</p>
      <p>To select many cards at once, hold <strong>Shift</strong> and drag on empty space to draw a selection rectangle. Any card whose center falls inside the rectangle gets selected.</p>
      <p>Hold <strong>Ctrl</strong> when releasing the rectangle to add to an existing selection instead of replacing it.</p>
      <p>Press <strong>Escape</strong> or click empty space to deselect all. The orange badge at the bottom shows how many cards are selected.</p>
    ` },
    { title: 'Views & Layout', icon: 'ğŸ”€', html: `
      <p>Use the <strong>â¬</strong> button (bottom-right) to switch between <strong>horizontal</strong> (ancestors fan right) and <strong>vertical</strong> (ancestors go up) layouts.</p>
      <p>Use the <strong>â†º</strong> button to reset all cards to their computed positions.</p>
      <p>The <strong>âŠ¡ Fit</strong> button zooms and pans to show all cards. <strong>+</strong> and <strong>âˆ’</strong> control zoom level.</p>
    ` },
    { title: 'Detail Modal', icon: 'ğŸ“‹', html: `
      <p><strong>Right-click</strong> any card to open a detail modal showing vital information, parents, spouses, children, and siblings.</p>
      <p>Click any person link in the modal to navigate to them. The confidence badge shows data quality (High/Medium/Low/Speculative).</p>
    ` },
    { title: 'Search', icon: 'ğŸ”', html: `
      <p>Type in the search bar at the top to find any person by name. Results appear as you type (debounced). Click a result to navigate directly to that person as the new root.</p>
    ` },
    { title: 'Card Colors', icon: 'ğŸ¨', html: `
      <ul>
        <li><strong>Blue left border</strong> â€” Male</li>
        <li><strong>Red left border</strong> â€” Female</li>
        <li><strong>Gray left border</strong> â€” Unknown sex</li>
        <li><strong>Gold border</strong> â€” Root person (current focus)</li>
        <li><strong>Orange outline</strong> â€” Selected card</li>
        <li><strong>Confidence dot</strong> â€” Green (high), Yellow (medium), Orange (low), Red (speculative)</li>
      </ul>
    ` }
  ]
});
</script>
</body>
</html>

